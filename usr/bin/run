#!/usr/bin/env python
# -*- mode: python -*-
__VERSION__ = "1.5"

import sys, os
import subprocess

TIME_FMT="[time] %Us user %Ss sys %P cpu %t mem (total: %e)"

class FiletypeError(ValueError): pass

def get_type(f):
    ptype = f.split(".")
    if len(ptype) > 1:
        return ptype[-1]
    else:
        return None

def tempdir():
    import tempfile
    import shutil
    import atexit

    path = tempfile.mkdtemp()
    atexit.register(shutil.rmtree, path)
    return path

def run(f, args, measure=False, filetype=None):
    if filetype == None:
        filetype = get_type(f)

    if not Extensions.have(filetype, "run"):
        if filetype:
            raise ValueError("Unsupported file type")
        else:
            raise FiletypeError("Unable to divine file type")

    d = tempdir()
    commands = Extensions.get(filetype, "run")(f, args=args, tempdir=d)

    for cmd in commands:
        sh = cmd
        if measure:
            sh = ["time", "-f", TIME_FMT] + sh
        subprocess.call(sh)

def compile(f, args, outfile=None, filetype=None):
    if filetype == None:
        filetype = get_type(f)

    if not Extensions.have(filetype, "compile"):
        if filetype:
            raise ValueError("Unsupported file type")
        else:
            raise FiletypeError("Unable to divine file type")

    if outfile == None:
        outfile = Extensions.get(filetype, "outfile")(f)
    elif os.path.isdir(outfile):
        fname = os.path.basename(Extensions.get(filetype, "outfile")(f))
        outfile = os.path.join(outfile, fname)

    d = tempdir()
    commands = Extensions.get(filetype, "compile")(f, args=args, tempdir=d, target=outfile)

    for cmd in commands:
        subprocess.call(cmd)

class Extensions:
    @classmethod
    def have(cls, ext, type):
        return ext and hasattr(cls, ext) and hasattr(getattr(cls, ext), type)

    @classmethod
    def get(cls, ext, type):
        return ext and getattr(getattr(cls, ext), type)
    
    class c:
        @classmethod
        def run(cls, f, args, tempdir):
            yield ["gcc", "-O3", "-o", os.path.join(tempdir, "-out")]
            yield [os.path.join(tempdir, "-out")] + args

        @classmethod
        def compile(cls, f, args, tempdir, target):
            yield ["gcc", "-O3", "-o", os.path.join(tempdir, "-out")]

        @classmethod
        def outfile(cls, f):
            return f.split(".", 1)[0]

    class cpp:
        @classmethod
        def run(cls, f, args, tempdir):
            yield ["g++", "-O3", "-o", os.path.join(tempdir, "-out")]
            yield [os.path.join(tempdir, "-out")] + args

        @classmethod
        def compile(cls, f, args, tempdir, target):
            yield ["g++", "-O3", "-o", os.path.join(tempdir, "-out")] + args

        @classmethod
        def outfile(cls, f):
            return f.split("/")[-1].rsplit(".", 1)[0]

    class hs:
        @classmethod
        def run(cls, f, args, tempdir):
            yield ["ghc", "-O3", "-o", os.path.join(tempdir, "-out"),
                   "-outputdir", tempdir, "--make"]
            yield [os.path.join(tempdir, "-out")] + args

        @classmethod
        def compile(cls, f, args, tempdir, target):
            yield ["g++", "-O3", "-o", os.path.join(tempdir, "-out"),
                   "-outputdir", tempdir, "--make"] + args

        @classmethod
        def outfile(cls, f):
            return f.split("/")[-1].rsplit(".", 1)[0]

    class java:
        @classmethod
        def run(cls, f, args, tempdir):
            yield ["javac", "-d", tempdir, f]
            yield ["java", "-cp", tempdir, cls.outfile(f)]

        @classmethod
        def compile(cls, f, args, tempdir, target):
            yield ["javac", "-d", tempdir, f] + args
            yield ["mv", os.path.join(tempdir, cls.outfile(f) + ".class"), target]

        @classmethod
        def outfile(cls, f):
            return f.split("/")[-1].rsplit(".", 1)[0]

    class org:
        @classmethod
        def EMACS_COMMAND(cls, f):
            return [ "emacs",
                     "--batch", "-Q",
                     "--load", "~/.emacs.d/export.el",
                     "--eval", "(require 'org-install)",
                     "--visit", f,
                     "--funcall", "org-export-as-latex-batch"]
        
        @classmethod
        def run(cls, f, tempdir, args):
            yield ["cp", f, tempdir]
            yield EMACS_COMMAND(cls.tempname(tempdir, f)) + args
            yield ["rubber", "-d", "--into", tempdir,
                   cls.texname(tempdir, f)] + args
            yield ["evince", cls.outname(tempdir, f)]

        @classmethod
        def compile(cls, f, tempdir, target, args):
            yield ["cp", f, tempdir]
            yield EMACS_COMMAND(cls.tempname(tempdir, f)) + args
            yield ["rubber", "-d", "--into", tempdir,
                   cls.texname(tempdir, f)] + args
            yield ["mv", cls.outname(tempdir, f), target]

        @classmethod
        def texfile(cls, f):
            return f.rsplit(".", 1)[0] + ".tex"

        @classmethod
        def outfile(cls, f):
            return f.rsplit(".", 1)[0] + ".pdf"
        
        @classmethod
        def tempname(cls, tempdir, f):
            return os.path.join(tempdir, os.path.split(f)[1])

        @classmethod
        def texname(cls, tempdir, f):
            return os.path.join(tempdir, os.path.split(cls.texfile(f))[1])
            
    class py:
        @classmethod
        def run(cls, f, args, tempdir):
            yield ["python", f] + args

    class sh:
        @classmethod
        def run(cls, f, args, tempdir):
            yield ["bash", f] + args

    class tex:
        @classmethod
        def run(cls, f, args, tempdir):
            yield ["rubber", "-d", "--into", tempdir, f] + args
            yield ["evince", os.path.join(tempdir,
                                          os.path.split(cls.outfile(f))[1])]

        @classmethod
        def compile(cls, f, args, tempdir, target):
            yield ["rubber", "-d", "--into", tempdir, f] + args
            yield ["mv", os.path.join(tempdir, os.path.split(cls.outfile(f))[1]), target]

        @classmethod
        def outfile(cls, f):
            return f.rsplit(".", 1)[0] + ".pdf"
            
if __name__ == "__main__":
    from optparse import OptionParser

    parser = OptionParser(usage="Compile and run files of various types\n\nUSAGE: %prog [OPTIONS] file [-- args]", version="%prog " + __VERSION__)
    parser.add_option("-c", "--compile", action="store_true", dest="compile", help="Compile file instead of just running it", default=False)
    parser.add_option("-m", "--measure", action="store_true", dest="measure", help="Measure program runtime with `time`", default=False)
    parser.add_option("-o", "--outfile", action="store", type="string", dest="outfile", help="Location of compiled code; use with `--compile`", default=None)
    parser.add_option("-t", "--type", action="store", type="string", dest="filetype", help="Type of code in file", default=None)

    def print_help():
        print("Compile and run files of various types")
        print()
        print("USAGE: run <file>                Run <file>")
        print("     | run -m <file>             Run <file>, and measure runtime")
        print("     | run -c <file>             Compile <file>")
        print("     | run -c <file> -o <dest>   Compile <file> into file <dest>")
        print()
        print("One can also always pass the option `-t <type>` to specify the type of <file>")

    parser.print_help = print_help
    options, args = parser.parse_args()
    
    if options.outfile and not options.compile:
        parser.error("`--outfile` requires `--compile` to be set")

    if options.compile and options.measure:
        parser.error("Setting both `--measure` and `--compile` makes no sense; what would I measure?")
    
    if len(args) == 0:
        parser.error("At least one argument must be specified!")

    if options.compile:
        compile(args[0], args[1:], outfile=options.outfile, filetype=options.filetype)
    else:
        run(args[0], args[1:], measure=options.measure, filetype=options.filetype)
