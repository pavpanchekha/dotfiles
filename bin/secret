#!/usr/bin/env python
# -*- mode: python -*- 
"""
A simple command-line password manager.  Aims, in particular, to use a
very lightweight interface.  All interaction is through the command
line, and all input is through a simple dmenu system or through the
standard input or output.  I like to run it as `secret [name]` from my
XMonad setup.
"""

SECRETFILE = "/home/priv/secret.gpg"
VERSION = 0.50
MIN_VERSION = 0.50

import os         # For reading the GPGKEY environment variable
import sys        # For reading from stdin
import subprocess # For starting subcommands, such as openssl
import tempfile   # For securely passing passwords to processes

def openpipe(command_line):
    """Start a process with input, output, and error going to a pipe"""

    return subprocess.Popen(command_line, stdin=subprocess.PIPE, 
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                            universal_newlines=True)

class SecretFile:
    """Control the reading and writing of an encrypted password file."""

    HEADER = "Version %s\n\n" % VERSION

    class EncryptionError(Exception): pass

    def __init__(self, file, password):
        self.file = file
        self.hash = password

    def read(self):
        """
        Return the decrypted contents of the password file.

        Uses GPG for the crypto bits.  Verifies the file
        signature and raises an EncryptionError if the file is
        corrupted.
        """
        
        f = tempfile.NamedTemporaryFile(mode="w")
        f.write(self.hash)
        f.flush()

        enc = openpipe(["gpg", "--decrypt", "--batch",
                        "--passphrase-file", f.name, self.file])
        out, err = enc.communicate()
        if not out: raise self.EncryptionError(err)
        f.close()
        
        header, body = self.header(out)
        self.verify(header)
        return body
        
    def write(self, body):
        """
        Replace the contents of the password file.

        Uses GPG for the crypto bits.  Signs the file and raises
        an EncryptionError if the file is corrputed.
        """

        # Add header
        text = self.HEADER + body

        f = tempfile.NamedTemporaryFile(mode="w")
        f.write(self.hash)
        f.flush()

        key = os.environ.get("GPGKEY")
        opts = ["--default-recipient-self"]
        if key: opts.extend(["--default-key", key])
        os.unlink(self.file)
        enc = openpipe(["gpg", "--encrypt", "--sign", "--batch"] + opts +
                       ["--passphrase-file", f.name, "--output", self.file])
        out, err = enc.communicate(text)
        print(err)
        f.close()
        
    def append(self, text):
        current = self.read()
        self.write(current + text)

    @classmethod
    def header(cls, text):
        if not text:
            return cls.HEADER, ""

        split = text.split("\n\n", 1)

        if len(split) != 2:
            raise SecretFile.EncryptionError("Invalid password or corrputed file (could not find header line)")

        header = split[0]
        body = split[1]
        return header, body
        
    @classmethod
    def verify(cls, header):
        if len(header) == 0:
            return VERSION

        if not header.startswith("Version"):
            raise SecretFile.EncryptionError("Invalid file header line; file likely corrupted")

        try:
            file_version = header.split()[1]
            assert float(file_version) >= MIN_VERSION
        except (ValueError, IndexError):
            raise SecretFile.EncryptionError("Could not parse format version")
        except AssertionError:
            raise SecretFile.EncryptionError("File from too old a version; use an older version of secret to upgrade the file format")
        
        return file_version

class Input:
    """Namespace for methods of reading a password"""

    @staticmethod
    def dmenu():
        """Use a black-on-black dmenu to read in the password"""
        getpwd = openpipe(["dmenu", "-p", "Master Password: ",
                           "-fn", "Terminus-12",
                           "-nb", "#000000", "-nf", "#000000",
                           "-sb", "#000000", "-sf", "#ffffff"])
        pw, _ = getpwd.communicate("")
        if getpwd.returncode: sys.exit(getpwd.returncode)
        if pw[-1] == "\n": pw = pw[:-1]
        return pw

    @staticmethod
    def getpass():
        """Read a password from the standard input"""
        import getpass
        return getpass.getpass("Master Password: ")

    default = dmenu

class Output:
    """Namespace for methods of printing a password"""
    
    @staticmethod
    def xclip(text):
        """Write the password to the X clipboard"""
        proc = subprocess.Popen(["xclip", "-selection", "clipboard"], stdin=subprocess.PIPE)
        proc.communicate(text.encode('utf-8'))
    
    @staticmethod
    def stdout(text):
        """Print the password, in the clear, on the standard output"""
        print(text)

    default = xclip

def get_password(sfile, name):
    pw = None

    read_pw = False
    for line in sfile.read().split("\n"):
        if line.startswith("Name") and line.split()[1] == name:
            read_pw = True
        elif line.startswith("Password") and read_pw:
            pw = line[line.index("\"")+1:line.rindex("\"")]
            read_pw = False

    if pw:
        return pw
    else:
        raise ValueError("No such secret")

def list_accounts(sfile):
    for line in sfile.read().split("\n"):
        if line.startswith("Name"):
            print(line.split()[1])

def dump_secrets(sfile):
    print(sfile.read())

def rehash(sfile):
    text = sfile.read()
    sfile.hash = Input.default()
    sfile.write(text)

def readin(sfile, text):
    sfile.write(text)

def generate_password(len=12):
    lower  = "abcdefghijklmnopqrstuvwxyz"
    upper  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    number = "0123456789"
    chars  = "~!@#$%^&()_+-=?/>.<,|\\\"':;"

    import random
    passwd = random.choice(lower) + random.choice(upper) + random.choice(number) + random.choice(chars)

    valid = lower * 3 + upper * 3 + number * 5 + chars * 2
    for i in range(4, len):
        passwd += random.choice(valid)

    l = list(passwd)
    random.shuffle(l)
    return "".join(l)

def new_account(sfile, name, url):
    pwd = generate_password()
    sfile.append("\nName %s\n" % name + "URL %s\n" % url + "Password \"%s\"\n" % pwd)
    return pwd

def main():
    prompt_password = Input.default
    if "-g" in sys.argv:
        sys.argv.remove("-g")
        prompt_password = Input.getpass

    pw = prompt_password()

    output = Output.default
    if "-p" in sys.argv:
        sys.argv.remove("-p")
        output = Output.stdout

    sfile = SecretFile(SECRETFILE, pw)
    if len(sys.argv) > 1 and sys.argv[1] == "-n":
        assert len(sys.argv) == 4, "USAGE: secret -n <name> <url>"
        passwd = new_account(sfile, sys.argv[2], sys.argv[3])
        output(passwd)
    elif len(sys.argv) > 1 and sys.argv[1] == "-l":
        list_accounts(sfile)
    elif len(sys.argv) > 1 and sys.argv[1] == "-d":
        dump_secrets(sfile)
    elif len(sys.argv) > 1 and sys.argv[1] == "-r":
        readin(sfile, sys.stdin.read())
    elif len(sys.argv) > 1 and sys.argv[1] == "--rehash":
        rehash(sfile)
    else:
        assert len(sys.argv) == 2
        passwd = get_password(sfile, sys.argv[1])
        output(passwd)

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] in ("-h", "--help", "-?"):
        print("Manage passwords")
        print()
        print("USAGE: secret <name>     Get password for account <name>")
        print("     | secret -n <name> <url>")
        print("     |                   Generate a new account <name> at <url>")
        print("     | secret -l         List all accounts")
        print("     | secret -d         Dump all account data")
        print("     | secret -r         Read in new account data")
        print("     | secret --rehash   Reencrypt the database with a new key")
        print()
        print("OPTIONS: -g              Read the encryption key from the console")
        print("         -p              Print the password to the console")
    else:
        try:
            main()
        except SecretFile.EncryptionError as e:
            sys.stderr.write("Encryption Error: {}\n".format(e));
