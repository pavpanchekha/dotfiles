#+TITLE: Emacs Snippets

* W3M Fixes
** New blank tab

I prefer there to be a key to enter a new URL, blank-slate.

#+BEGIN_SRC emacs-lisp
  (defun w3m-clean-slate-goto-url (url)
    (interactive (list (w3m-input-url nil "" nil nil 'feeling-lucky)))
    (w3m-goto-url url))
#+END_SRC

The symmetric operations should clearly exist for tabs.

#+BEGIN_SRC emacs-lisp
  (defun w3m-clean-slate-goto-url-new-session (url)
    (interactive (list (w3m-input-url nil "" nil nil 'feeling-lucky)))
    (w3m-goto-url-new-session url))
#+END_SRC

** Open in Background

Unfortunately, the open-in-new-tab command switches to the new tab
right away; this is silly.

#+BEGIN_SRC emacs-lisp
  (defun w3m-view-this-url-new-session-background ()
    "Display the page of the link under point in a new session, in
  the background. If the region is active, use the
  `w3m-open-all-links-in-new-session' command instead."
    (interactive)

    (save-window-excursion
      (call-interactively 'w3m-view-this-url-new-session)))
#+END_SRC
** Clamp next buffer

When a tab is closed, W3M should shift to the right tab, not the left tab.

#+BEGIN_SRC emacs-lisp
  (defun clamp (a n)
    (cond
     ((< a 0) 0)
     ((> a n) n)
     (t a)))

  (defun w3m-clamp-next-buffer (arg)
    "Turn ARG pages of emacs-w3m buffers ahead."
    (interactive "p")
    (unless arg (setq arg 1))
    (when (and (/= arg 0) (eq major-mode 'w3m-mode))
      (w3m-history-store-position)
      (let* ((buffers (w3m-list-buffers))
         (len (length buffers)))
        (switch-to-buffer
         (nth (clamp (+ arg (- len (length (memq (current-buffer) buffers))))
           len)
          buffers)))
      (w3m-history-restore-position)
      (run-hooks 'w3m-select-buffer-hook)
      (w3m-select-buffer-update)))

  (add-hook 'w3m-delete-buffer-hook (lambda () (w3m-clamp-next-buffer 1)))

#+END_SRC

* LaTeX Compilation

LaTeX also could use a quick tool to compile and view a source file.
I use the =compile= command for this.

#+BEGIN_SRC emacs-lisp
  (defun latex-compile (file)
    (interactive (list (buffer-file-name)))

    (make-local-variable 'latex-compile-outfile)

    (let ((first-run (not (boundp 'latex-compile-outfile))))
      (when (or first-run (not (get-file-buffer latex-compile-outfile)))
        (setf latex-compile-outfile
              (make-temp-file "emacs-latex-compile-" nil ".pdf"))
        (setf first-run t))

      (save-window-excursion
        (shell-command (concat "run -c " file " -o " latex-compile-outfile)))

      (if first-run
          (find-file-other-window latex-compile-outfile)
        (progn
          (set-buffer (get-file-buffer latex-compile-outfile))
          (doc-view-revert-buffer t t)))))
#+END_SRC

* Mu For Emacs

I'm now reading my mail in =mu4e=, from the =mu-git= Arch Linux package.
This package is a lot like =notmuch= in that it's search-based and
works well with =offlineimap=, but has a much nicer interface and tries
very hard to stay compatible with the upstream IMAP folder.

#+BEGIN_SRC emacs-lisp :tangle nil
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
(require 'mu4e)
#+END_SRC

I need to tell Mu which folders store what on my system.  Note that I
only sync "important" messages with GMail to my system, so the
archive folder is the "important" folder.

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf mu4e-maildir "~/mail"
        mu4e-sent-folder "/sent"
        mu4e-drafts-folder "/drafts"
        mu4e-trash-folder "/trash"
        mu4e-refile-folder "/important")
  (setf mu4e-attachment-dir  "/tmp")
#+END_SRC

Mail is synced with =offlineimap=, so I tell Mu to run that to get new
mail.  OfflineIMAP will automatically run the Mu indexer.

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf mu4e-get-mail-command "mu index -m ~/mail --my-address me@pavpanchekha.com")
#+END_SRC

Finally, since I'm using GMail, GMail will automatically deal with
filing sent messages, so I can tell Mu to just delete sent messages.

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf mu4e-sent-messages-behavior 'delete)
#+END_SRC

In all of the =mu4e= modes, I want the Evil extensions off, since they
do naught but get in the way.  But somehow, this doesn't work for
=mu4e-view-mode=, so we use a special dispension for that.

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf evil-emacs-state-modes (list* 'mu4e-headers-mode 'mu4e-main-mode
                                      'mu4e-main-mode 'mu4e-view-mode
                                      evil-emacs-state-modes))
  (add-hook 'mu4e-view-mode-hook 'evil-emacs-state)
#+END_SRC

There're a few graphical things to change about Mu4e:

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf mu4e-use-fancy-chars t)
  (setf mu4e-view-show-images t)
  (setf mu4e-headers-skip-duplicates t)
  (setf mu4e-headers-include-related t)
#+END_SRC

** Sending mail

My mail gets sent through the GMail IMAP server. I used to use msmtp for sending mail, but I’ve now switched to using smtpmail.el, since it’s nice to have an Emacs-native solution.

#+BEGIN_SRC emacs-lisp
(setq send-mail-function 'smtpmail-send-it)
(setq message-send-mail-function 'smtpmail-send-it)
#+END_SRC

We now set up SMTPMail to use GMail.

#+BEGIN_SRC emacs-lisp
(setq smtpmail-smtp-server "smtp.gmail.com")
(setq smtpmail-smtp-service 587)
#+END_SRC

We then set up TLS for GMail’s connection:

#+BEGIN_SRC emacs-lisp
  (setq starttls-use-gnutls t)

  (setq smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        smtpmail-smtp-user "me@pavpanchekha.com"
        smtpmail-local-domain "pavpanchekha.com"
        smtpmail-sendto-domain "pavpanchekha.com"
        smtpmail-debug-info t)

  (require 'smtpmail)
#+END_SRC

** Composing messages

When composing replies, there are a few things I change from their defaults.  Firstly, I prefer quotes not to have citations, since I rarely participate in massive, many-person email threads.

#+BEGIN_SRC emacs-lisp
(setf message-citation-line-format "")
#+END_SRC

I also have a standard signature.

#+BEGIN_SRC emacs-lisp
(setf message-signature " - Pavel Panchekha")
#+END_SRC

** Bookmarks

I have a few bookmarks that set up my email flow.

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf mu4e-maildir-shortcuts
    '(("/inbox" . ?i)
      ("flag:unread AND maildir:/important"  . ?u)))
#+END_SRC
* Org Mode

** Agenda View

I use the agenda view a lot, so I customize it a bit.  The agenda
should show two days (including, yes, the ones without events); it
shouldn't show me things I've done; and I won't worry about starting
on a weekend or weekday.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-ndays 1)
  (setq org-agenda-span 2)
  (setq org-deadline-warning-days 3)

  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-start-on-weekday nil)
#+END_SRC

Since all of my TODO entries are in one file, I don't need the agenda
view to tell me what file a TODO entry comes from.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-file-regexp "\\`[^.].*\\.\\(txt\\|org\\)\\'")
  (setq org-agenda-files '("~/notes/"))
  (setq org-agenda-prefix-format
        '((agenda . " %i %?-12t% s")
          (timeline . "  % s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
#+END_SRC

Finally, given my use of the TODO list, I would like fewer deadline
reminders and more scheduled reminders

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown nil)
#+END_SRC

** Todo Keywords

The keywords here represent a good chunk of possible work-flows.  TODO
to DONE is the standard one, but sometimes I go to WONT or spent time
cycling between TODO and WAIT.  SOMEDAY exists for the projects that
I'd like to do, but that are currently in limbo.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "SOMEDAY(s)" "|" "DONE(d)" "WAIT(w)" "WONT(n)")))
(setq org-use-fast-todo-selection t)
#+END_SRC

** Key bindings

Some key bindings are not bound by Org automatically, so I have to bind
them myself.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
#+END_SRC
