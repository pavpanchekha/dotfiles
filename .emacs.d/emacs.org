#+TITLE: Emacs Initialization Script

All of my Emacs initialization is contained within this one Literate
Babel file.  I use the Babel system in Org-mode to evaluate the code
within on Emacs startup, which lets me write nice descriptive text for
my code.  My =.emacs.d/init.el= file contains only:

: (require 'org-install)
: (require 'ob-tangle)
: (mapc #'org-babel-load-file (directory-files "~/.emacs.d/" t "\\.org$"))

More on this method can be found [[http://orgmode.org/worg/org-contrib/babel/intro.html#sec-8_2][in the Babel tutorial]].

* Personal Info

Emacs might as well know my name and email address.  I trust it.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Pavel Panchekha")
(setq user-mail-address "me@pavpanchekha.com")
#+END_SRC

* File Information

To make sure that Emacs can load some extra libraries that I've set
up, I need to add my local =load-path= to the list.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/load-path")
#+END_SRC

Also, I like to keep my custom-set variables from poluting my other
files, so I like to move the =custom-file=.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

Finally, since I publish this file on the internet, I don't want
passwords in it.  So I keep them elsewhere, and load them here:

#+BEGIN_SRC emacs-lisp
(org-babel-load-file "~/.emacs.d/passwords.org")
#+END_SRC

* GUI Settings

Some things Emacs does by default just use up screen real estate and
programmer patience.  Note that =tool-bar-mode= requires a *nonzero*
parameter, not a truthy parameter, to display the toolbar.  This is
absolutely absurd, but what can one do?

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
(set-scroll-bar-mode nil)
(tool-bar-mode 0)
#+END_SRC

I'm not yet pro enough to forsake =menu-bar-mode=, though one day I'll
get there.

Also, I like knowing where my files end; ergo:

#+BEGIN_SRC emacs-lisp
(if (not indicate-empty-lines)
  (toggle-indicate-empty-lines))
#+END_SRC

** Modeline Goodies

The modeline should really be pressed into useful service.  I make it
display the time, and for the position display, have it give the column
number and file size:

#+BEGIN_SRC emacs-lisp
(display-time-mode t)
(setq column-number-mode t)
(setq size-indication-mode t)
#+END_SRC
* Text Editing
** File Behavior

Emacs has some stupid defaults, such as making those =file~= files and
using tabs for indentation.  I also make Emacs add final newlines and
to prompt me for only single characters (why is that default?).

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq-default indent-tabs-mode nil)
(setq require-final-newline t)
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Also, I often have multiple buffers open with the same name.  Emacs
usually deals with this by appending the buffer number to the buffer
name.  This is hard to keep track of.  Instead, the =uniquify= library
uses the parent directory name, which I usually know.

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'post-forward-angle-brackets)
#+END_SRC

** Searching and Scrolling

For searching, I enable highlighting as-I-search for both searches and
search/replaces.  Also, searches are made case-insensitive.  

#+BEGIN_SRC emacs-lisp
(setq search-highlight t)
(setq query-replace-highlight t)
(setq case-fold-search t)
#+END_SRC emacs-lisp

For scrolling, I ask Emacs to scroll at most five lines at a time and
to keep 5 lines between the cursor and the top/bottom of the page.

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 5)
(setq scroll-margin 5)
#+END_SRC

** Vim Key Bindings

The most obvious key-binding setup is viper mode.

#+BEGIN_SRC emacs-lisp
  (setq viper-inhibit-startup-message t)
  (setq viper-expert-level 5)
  (setq viper-mode t)
  
  (require 'viper)
#+END_SRC

Viper mode is extended (with things like visual mode) in Vimpulse.  I
add my personal load path because Vimpulse is not yet a part of the
default Emacs distribution.

#+BEGIN_SRC emacs-lisp
(require 'vimpulse)
#+END_SRC

Another key binding I really miss from Vim is the spelling key
bindings =zg= and =z==.  I can add them back with Vimpulse's
=vimpulse-map=; I make them hook into ispell (which I like much better
than Vim's system, actually, since I can see context as I correct).

#+BEGIN_SRC emacs-lisp
(vimpulse-map "z=" 'ispell-word)
(vimpulse-map "zg" 'ispell-insert-word)
#+END_SRC

** Ispell =ispell-insert-word=

Above, I mapped =zg= to =ispell-insert-word=.  Unfortunately,
=ispell-insert-word= doesn't exist.  So, we write our own.

#+BEGIN_SRC emacs-lisp
(defun ispell-insert-word ()
  (interactive)
#+END_SRC

First, we need to *get* the current word.  We don't need to explicitly
use =ispell-following-word=, since =ispell-get-word= does this for us.
=ispell-get-word= returns a list of =word=, =start=, =end= (though its
documentation certainly doesn't hint at such), so we call =car= to
extract the word itself.

#+BEGIN_SRC emacs-lisp
  (let ((word (car (ispell-get-word nil))))
#+END_SRC

Now we can call =ispell-send-string=.  Its documentation is pretty
weak (and that's if I want to be nice), but from reading the code of
=ispell-command-loop= (search for =?i=), it seems like we want to send
=*word\n=, where =word= is the word in question.

#+BEGIN_SRC emacs-lisp
  (ispell-send-string (concat "*" word "\n"))
#+END_SRC

Finally, since we modified the dictionary, we want to save it.  To be
nice, we're going to first mark the dictionary as modified.  We only
want to force a save, though, if the dictionary was clean before-hand,
so we save the old value.

#+BEGIN_SRC emacs-lisp
  (let ((old-ispell-pdict-modified-p ispell-pdict-modified-p))
    (setq ispell-pdict-modified-p '(t))
#+END_SRC

And finally, we want force a save if necessary.  The "if necessary"
part is actually annoyingly complicated...

#+BEGIN_SRC emacs-lisp
    (when (or (and old-ispell-pdict-modified-p
                   (listp old-ispell-pdict-modified-p)
                   (car ispell-pdict-modified-p))
              (and ispell-pdict-modified-p
                   (not (listp ispell-pdict-modified-p)))))
#+END_SRC

But once that's out of the way, we can just call =ispell-pdict-save=
with =no-query=.

#+BEGIN_SRC emacs-lisp
      (ispell-pdict-save t))))
#+END_SRC

** General

I prefer to work with indented text at all times, so =RET= should be
bound to =newline-and-indent=, and some terminals have problems with
the delete key or something, so I keep the following bindings around
as well.  The last line there make =C-k= kill the whole line.

#+BEGIN_SRC emacs-lisp
(global-set-key [C-m] 'newline-and-indent)
(global-set-key [delete] 'delete-char)
(setq kill-whole-line t)
#+END_SRC

** Printing
*** Print to PDF

Sometimes, I need to print an Emacs buffer to PDF.  The standard
printing commands are less than ideal for this, since they rely on
=lpr=, a program I have no interest in installing and configuring.
Instead, I can use the Emacs =printing= package, which can export
buffers to Postscript, and then call =ps2pdf= to produce a PDF from
the Postscript.

First, I =require= in the =printing= package and ask it to install
itself into the Emacs menu tree.
  
#+BEGIN_SRC emacs-lisp
(require 'printing)
#+END_SRC

Now we write a function to print the current buffer.

#+BEGIN_SRC emacs-lisp
(defun print-to-pdf ()
  (interactive)
#+END_SRC

We want to use the function =pr-ps-buffer-pritn= from the =printing=
package.  We give it a temporary file to print to, and later we'll
=ps2pdf= that file.

#+BEGIN_SRC emacs-lisp
  (let* ((outfile (make-temp-file pr-ps-temp-file))
         (pdffile (concat outfile ".pdf")))
    (pr-ps-buffer-print 1 outfile)
    (shell-command (concat "ps2pdf "
                           (shell-quote-argument outfile)
                           " "
                           (shell-quote-argument pdffile)))
    (find-file pdffile)))
#+END_SRC
*** Print Settings

The default print settings are silly, especially once you consider
that my use case is print-to-PDF.  So I would rather print with syntax
highlighting and no headers.

#+BEGIN_SRC emacs-lisp
(setq pr-faces-p t
      ps-print-header nil
      ps-print-header-frame)
#+END_SRC

* Programming
** =run= Command

Normal boring definitions, just run a shell command.

#+BEGIN_SRC emacs-lisp
(defun run-command (file)
  (interactive (buffer-file-name))
  (shell-command (concat "run " file " &")))

(defun compile-command (file)
  (interactive (buffer-file-name))
  (shell-command (concat "run -c " file " &")))
#+END_SRC

Then we attach them to =[f5]= and =[C-f5]=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f5>") 'run-command)
(global-set-key (kbd "C-<f5>") 'compile-command)
#+END_SRC

** Slime

First, we tell Emacs where to find SLIME and load it.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/usr/share/emacs/site-lisp/slime")
(require 'slime)
#+END_SRC

Slime needs to be tols where to find my specific Swank loader (I
change what directory to dump FASLs in).  And, I set the Lisp to SBCL.

#+BEGIN_SRC emacs-lisp
(setq slime-backend "~/.emacs.d/slime/loader.lsp")
(setq inferior-lisp-program "/usr/bin/sbcl")
#+END_SRC

Now Slime can be set up.

#+BEGIN_SRC emacs-lisp
(slime-setup)
#+END_SRC

* Doc-View

I generally use doc-vew for long PDFs, so I find it best to have
continuous scrolling.

#+BEGIN_SRC emacs-lisp
(setq doc-view-continuous t)
#+END_SRC

Also, I often end up zooming a lot on PDFs, so I like rendering them
at high resolution.

#+BEGIN_SRC emacs-lisp
(setq doc-view-resolution 192)
#+END_SRC

** Key bindings

The PDF viewer is in sore need of Vim-style h/j/k/l movement keys

#+BEGIN_SRC emacs-lisp
(require 'doc-view)
(define-key doc-view-mode-map (kbd "j") 'doc-view-next-line-or-next-page)
(define-key doc-view-mode-map (kbd "k") 'doc-view-previous-line-or-previous-page)
(define-key doc-view-mode-map (kbd "h") 'image-backward-hscroll)
(define-key doc-view-mode-map (kbd "l") 'image-forward-hscroll)
#+END_SRC
* Mode-specific Behaviors
** Text-like Modes

Since I like Org-mode so much, I feel it should be default for text
files.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
#+END_SRC

Other modes I use quite a bit are Restructured Text (for writing
Python code) and $\LaTeX$ (for class):

#+BEGIN_SRC emacs-lisp
(defun text-minor-modes ()
  (interactive)
  (auto-fill-mode)
  (flyspell-mode))

(add-hook 'text-mode-hook 'text-minor-modes)
(add-hook 'LaTeX-mode-hook 'text-minor-modes)
(add-hook 'org-mode-hook 'text-minor-modes)
#+END_SRC

Of course, if we're activating ISpell, we should set it up.  Firstly
we want to tell it to use =ispell=, to check spelling against American
English, and where my dictionary is.

#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "/usr/bin/ispell")
(setq ispell-dictionary "american")
(setq ispell-personal-dictionary "~/.emacs.d/dict")
#+END_SRC

** LaTeX

LaTeX requires a bit more setup, simply because *of course* I want
AucTeX.

#+BEGIN_SRC emacs-lisp
(load "auctex.el" nil t t)
(load "preview-latex.el" nil t t)
#+END_SRC

The default previews are a bit small for my tastes.

#+BEGIN_SRC emacs-lisp
(setq preview-scale-function 1.1)
#+END_SRC

** Language Modes

Some modes I just need to =(require)= in.  First, =load-path= need
setting up.

#+BEGIN_SRC emacs-lisp
(setq load-path
      (append load-path
              '("/usr/share/emacs/site-lisp/clojure-mode"
                "/usr/share/emacs/site-lisp/haskell-mode")))
#+END_SRC

Now we can require in Haskell and Clojure modes.

#+BEGIN_SRC emacs-lisp
(require 'haskell-mode)
(require 'clojure-mode)
#+END_SRC
* Org Mode

We first include Org mode, and tell it which modules to use.

#+BEGIN_SRC emacs-lisp
(require 'org-install)

(setq org-modules '(org-docview org-jsinfo org-irc org-gnus org-w3m))
#+END_SRC

First things first!  We should set up the file structure.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/notes/")
(setq org-agenda-files '("~/notes/"))
(setq org-default-notes-file (concat org-directory "pavel.org"))
#+END_SRC

Let's throw in a very minor editing thing (hitting =M-RET= shouldn't
split a bullet point in two).

#+BEGIN_SRC emacs-lisp
(setq org-M-RET-may-split-line '((default)))
#+END_SRC

** Agenda View

I use the agenda view a lot, so I customize it a bit.  The agenda
should show seven days (including, yes, the ones without events); it
shouldn't show me things I've done; and I won't worry about starting
on a weekend or weekday.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-ndays 7)
(setq org-agenda-show-all-dates t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-start-on-weekday nil)
#+END_SRC

** TODO Templates

Org-capture is what I use for editing templated events (it's so much
nicer than the old =remember= system...)  Unfortunately, I've been
reorganizing recently, so all of my old templates are gone, the above
TODO in their place.

** Todo Keywords

I also have several possible workflows for TODO-style labels, so I add
those keywords.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "SOMEDAY(s)" "MORE(m)" "|" "DONE(d)" "WAIT(w)" "WONT(n)")))
(setq org-use-fast-todo-selection t)
#+END_SRC

** Entities
Since I use things like \RR so often, I made them into entities, so that
Org can typeset them nicely.

#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities t
      org-entities-user '(("CC" "\\CC" t "&#8450;" "C" "C" "ℂ")
                          ("FF" "\\FF" t "&#120125;" "F" "F" "𝔽")
                          ("HH" "\\HH" t "&#8461;" "H" "H" "ℍ")
                          ("NN" "\\NN" t "&#8469;" "N" "N" "ℕ")
                          ("PP" "\\PP" t "&#8473;" "P" "P" "ℙ")
                          ("QQ" "\\QQ" t "&#8474;" "Q" "Q" "ℚ")
                          ("RR" "\\RR" t "&#8477;" "R" "R" "ℝ")
                          ("ZZ" "\\ZZ" t "&#8484;" "Z" "Z" "ℤ")))
#+END_SRC

** Keybindings
Some keybindings are not bound by Org automatically, so I have to bind
them myself.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
#+END_SRC

** MobileOrg

#+BEGIN_SRC emacs-lisp
(setq org-mobile-inbox-for-pull "~/notes/inbox.org")
(setq org-mobile-directory "~/Dropbox/MobileOrg")
#+END_SRC

* Games

It's very important that score files are placed correctly (can't lose
my tetris high scores!):

#+BEGIN_SRC emacs-lisp
(setq tetris-score-file "~/.emacs.d/scores/tetris")
(setq snake-score-file  "~/.emacs.d/scores/snake")
#+END_SRC

* Magit
Magit needs a =(require)= and an autoload.

#+BEGIN_SRC emacs-lisp
(require 'magit)
(autoload 'magit-status "magit" nil)
#+END_SRC

* W3M Browser

W3M is a nice web browser to use for tasks such as reading Hacker
News.  If it got a bit more love, it would be perfect...

#+BEGIN_SRC emacs-lisp
(require 'w3m)
#+END_SRC

First off, W3M should use UTF8 everywhere it can.

#+BEGIN_SRC emacs-lisp
(setq w3m-coding-system 'utf-8
      w3m-default-coding-system 'utf-8
      w3m-file-coding-system 'utf-8
      w3m-file-name-coding-system 'utf-8
      w3m-terminal-coding-system 'utf-8)
#+END_SRC

I change a few file locations.

#+BEGIN_SRC emacs-lisp
(setq w3m-default-save-directory "/tmp/")
(setq w3m-icon-directory "/tmp/")
#+END_SRC

W3M has some features that are, for whatever reason, off by default
(they're /experimental/; eh, work fine).

#+BEGIN_SRC emacs-lisp
(setq w3m-use-cookies t w3m-use-favicon t)
#+END_SRC

Finally I set up my homepage.

#+BEGIN_SRC emacs-lisp
(setq w3m-home-page "about:blank")
#+END_SRC

** Default Browser

I prefer to set Chrome as Emacs's default browser, simply because
there are lots of sites W3M just doesn't work that well on.

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-generic)
(setq browse-url-generic-program "google-chrome")
#+END_SRC

However, I still like the ability to throw open W3M easily.

#+BEGIN_SRC emacs-lisp
(autoload 'w3m-browse-url "w3m" "Ask a WWW browser to show a URL." t)
#+END_SRC

So I make a quick keybinding for browsing a URL.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-xm" 'browse-url-at-point)
(global-set-key "\C-xM" 'w3m-browse-url-at-point)
#+END_SRC

** Keybindings

=f= for "follow" is a very nice and intuitive keybinding for following
links.

#+BEGIN_SRC emacs-lisp
(define-key w3m-mode-map (kbd "f") 'w3m-view-this-url)
(define-key w3m-mode-map (kbd "F") 'w3m-view-this-url-new-session)
#+END_SRC

I prefer there to be a key to enter a new URL, blank-slate; and =o=
for "open" sounds like a good keybinding.

#+BEGIN_SRC emacs-lisp
(defun clean-slate-goto-url (url)
  (interactive (list (w3m-input-url nil "" nil nil 'feeling-lucky)))
  (w3m-goto-url url))

(define-key w3m-mode-map (kbd "o")   'clean-slate-goto-url)
(define-key w3m-mode-map (kbd "O")   'w3m-goto-url)
(define-key w3m-mode-map (kbd "C-o") 'w3m-view-previous-page)
#+END_SRC

The symmetric operations should clearly exist for tabs.

#+BEGIN_SRC emacs-lisp
(defun clean-slate-goto-url-new-session (url)
  (interactive (list (w3m-input-url nil "" nil nil 'feeling-lucky)))
  (w3m-goto-url-new-session url))

(define-key w3m-mode-map (kbd "t") 'clean-slate-goto-url-new-session)
(define-key w3m-mode-map (kbd "T") 'w3m-goto-url-new-session)
#+END_SRC

=d= for "delete" is pretty common.

#+BEGIN_SRC emacs-lisp
(define-key w3m-mode-map (kbd "d") 'w3m-delete-buffer)
#+END_SRC

Finally, I try to implement Vim-style tab switching.  This is a bit
more work...

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'vim-tab-switching)
(define-key w3m-mode-map (kbd "g") 'vim-tab-switching)

(define-key vim-tab-switching "t" 'w3m-next-buffer)
(define-key vim-tab-switching "T" 'w3m-previous-buffer)
#+END_SRC

Continuing on the Vim tradition, a good key for searching is =/=.

#+BEGIN_SRC emacs-lisp
(define-key w3m-mode-map "/" 'isearch-forward)
#+END_SRC

* Gnus
** Finding Mail

I'm slowly trying to switch over to Gnus as my mail reader, given how
powerful people say it is.  The below is a configuration I stole from
the Internet[fn:where] which tells Gnus where to get my mail...

#+BEGIN_SRC emacs-lisp
(setq mail-sources '((maildir :path "~/mail/inbox")))
(setq mail-source-delete-incoming t)
(setq mail-default-directory "~/mail/")
#+END_SRC

... and how to send it.

#+BEGIN_SRC emacs-lisp
(setq sendmail-program "/usr/bin/msmtp")
#+END_SRC

We also want to explain to Gnus where to put mail.  This is the
inverse operation of the above.  We're going to tell Gnus to use the
=ml= format; one file per message seems cleanest.

#+BEGIN_SRC emacs-lisp
(setq gnus-select-method
  '(nnml ""
     (nnml-directory "~/mail/")
     (nnml-active-file "~/mail/active")
     (nnml-get-new-mail t)))
#+END_SRC

[fn:where] http://neverbow.blogspot.com/2006/09/gnus-works-with-fetchmail.html

** File Locations

Gnus' spewing of files all over my directory tree infuriates me.  A
bunch of variables need to get set to fix that.

The first and most important one eliminates the =~/News= folder.  I
use Gnus for mail, not news, and I like my folders lower-cased.

#+BEGIN_SRC emacs-lisp
(setq gnus-directory "~/mail")
#+END_SRC

Since I don't actually use newsgroups from Usenet (and who does
anymore), the =.newsrc= file is useless.

#+BEGIN_SRC emacs-lisp
(setq gnus-save-newsrc-file nil)
#+END_SRC

Finally, we can move that file so as not to clutter our home
directory.

#+BEGIN_SRC emacs-lisp
(setq gnus-startup-file "~/.emacs.d/newsrc")
#+END_SRC

=nnmail= also needs its own cache file.  Move that to =.emacs.d=:

#+BEGIN_SRC emacs-lisp
(setq nnmail-message-id-cache-file "~/.emacs.d/nnmail-cache")
#+END_SRC

** Message Sending

Firstly, I don't want to see the =In-Reply-To= header, so I add it to
the list.

#+BEGIN_SRC emacs-lisp
(add-hook 'message-mode-hook
          (lambda ()
            (add-to-list 'message-hidden-headers "^In-Reply-To:")
            (visual-line-mode)))

#+END_SRC

There's also the issue of =message= creating drafts in the =~/Mail=
folder; this is annoying since I don't generally have such a folder.
So to make it stop, I change its default folder:

#+BEGIN_SRC emacs-lisp
(setq message-directory "~/mail/")
(setq mml-default-directory "~/mail/")
#+END_SRC

Finally, a signature.  Mine is pretty trivial: my name.

#+BEGIN_SRC emacs-lisp
(setq mail-signature "Pavel Panchekha")
(setq message-signature "Pavel Panchekha")
#+END_SRC

** Archiving

Archiving emails is different; it is put by-group into the "archive"
folder.

#+BEGIN_SRC emacs-lisp
(setq gnus-message-archive-method
      '(nnfolder "archive"
		 (nnfolder-directory    "~/mail/archive")
		 (nnfolder-active-file  "~/mail/archive/active")
		 (nnfolder-get-new-mail nil)))
#+END_SRC

** Splitting

Since I subscribe to several lists, I need Gnus to split my mail for me.

#+BEGIN_SRC emacs-lisp
(setq nnmail-split-methods
  '(("racket"   "^\\(To\\|Cc\\):.*@\\(lists\\.\\)?racket-lang.org")
    ("lisp-hug" "^\\(To\\|Cc\\):.*lisp-hug@lispworks.com")
    ("reuse"    "^\\(To\\|Cc\\):.*reuse.*@mit.edu")
    ("food"     "^\\(To\\|Cc\\):.*free-food@mit.edu")
    ("esp"      "^\\(To\\|Cc\\):.*esp.*@mit.edu")
    ("esp"      "^\\(To\\|Cc\\):.*nutso-flaming-admins@mit.edu")
    ("ruscon"   "^\\(To\\|Cc\\):.*ruscon@mit.edu")
    ("hmmt"     "^\\(To\\|Cc\\):.*hmmt.*@mit.edu")
    ("org-mode" "^\\(To\\|Cc\\):.*emacs-orgmode@gnu.org")
    ("lsc"      "^Subject:.*[LSC")
    ("inbox"    "")))
#+END_SRC

True lists I can auto-expire, since they're saved elsewhere.  Same for
lists that I don't care too much about --- they're always saved in
GMail.

#+BEGIN_SRC emacs-lisp
(setq gnus-auto-expirable-newsgroups
      "reuse\\|lisp-hug\\|racket\\|ruscon\\|org-mode\\|lsc")
#+END_SRC

** PGP Encryption

Gnus comes with convenient methods for signing messages.  Let's turn
them on: we make Gnus sign/encrypt messages that are replies to
signed/encrypted messages.

#+BEGIN_SRC emacs-lisp
  (setq gnus-message-replysign t
        gnus-message-replyencrypt t
        gnus-message-replysignencrypted t)
#+END_SRC

* BBDB

I use the Big Brother Database for storing contact, so I've gotta
require it in.  Given my heavy Gnus use, I obviously tell BBDB to load
up Gnus support.

#+BEGIN_SRC emacs-lisp
(require 'bbdb)
(bbdb-initialize 'gnus 'message)
(add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
#+END_SRC

I want BBDB to automatically notice people I actually send mail to.

#+BEGIN_SRC emacs-lisp
(setq bbdb/mail-auto-create-p t)
(setq bbdb-notice-hook '(bbdb-auto-notes-hook))
#+END_SRC

BBDB could use to be a bit prettier.  I like it colorful and out of
the way:

#+BEGIN_SRC emacs-lisp
(setq bbdb-gui t)
(setq bbdb-pop-up-display-layout 'one-line)
#+END_SRC

Given my love for a well-organized home folder, I'd also rather move
the BBDB.

#+BEGIN_SRC emacs-lisp
(setq bbdb-file "~/.emacs.d/bbdb")
#+END_SRC

* Jabber

=jabber.el= is a great, great invention: it lets me view my Google
Chat in Emacs!  Require it, post-haste!

#+BEGIN_SRC emacs-lisp
(require 'jabber)
#+END_SRC

I also give =jabber.el= my account details.

#+BEGIN_SRC emacs-lisp
; Some variables
(setq jabber-account-list `(("pavpanchekha@gmail.com" 
                             (:password . ,my-jabber-password)
                             (:network-server . "talk.google.com") 
                             (:connection-type . ssl))))
#+END_SRC

Now, =jabber.el= has a bunch of honestly very odd defaults.  Firstly,
it tries to store avatars somewhere in my home folder.  Yep, more
shit there is definitely what I need.

#+BEGIN_SRC emacs-lisp
(setq jabber-avatar-cache-directory "/tmp/jabber-avatars")
#+END_SRC

The default prompts are just awfully wordy.  We fix this.

#+BEGIN_SRC emacs-lisp
(setq jabber-chat-buffer-show-avatar nil
      jabber-chat-foreign-prompt-format "> "
      jabber-chat-local-prompt-format "> "
      jabber-chat-system-prompt-format "*** "
      jabber-chat-time-format "%H:%M"
      jabber-default-show ""
      jabber-groupchat-prompt-format "%n> "
      jabber-muc-private-foreign-prompt-format "%g/%n> ")
#+END_SRC

There are also some assorted variables over here.  One day I'll
document them better.

#+BEGIN_SRC emacs-lisp
(setq jabber-backlog-days 3.0
      jabber-roster-line-format "%c %-25n %u %-8s"
      jabber-roster-show-title nil
      jabber-show-resources nil
      jabber-show-offline-contacts nil)
#+END_SRC

Some faces I want to set to make chatting more pleasant.

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(jabber-chat-prompt-foreign ((t (:foreground "red"))))
 '(jabber-chat-prompt-local ((t (:foreground "blue"))))
 '(jabber-chat-prompt-system ((t (:foreground "dark green" :weight bold))))
 '(jabber-roster-user-away ((t (:foreground "orange"))))
 '(jabber-roster-user-chatty ((t (:foreground "green"))))
 '(jabber-roster-user-online ((t (:foreground "dark green")))))
#+END_SRC

Lastly, I sometimes IM my friends URLs, and it's nice to make them all
hyperlinky.

#+BEGIN_SRC emacs-lisp
; Auto-urlize urls
(add-hook 'jabber-chat-mode-hook 'goto-address)
(jabber-connect-all)
#+END_SRC

* Shells
** Shell mode

My fish shell prompt isn't detected too well.  Let's fix that.

#+BEGIN_SRC emacs-lisp
(setq shell-prompt-pattern ".*$>")
#+END_SRC

** Eshell

Eshell doesn't actually require that much prodding.  The only thing I
do is change its directory.

#+BEGIN_SRC emacs-lisp
(setq eshell-directory-name "~/.emacs.d/eshell/")
#+END_SRC

** Multi-term

Multiterm requires a bit more setup.

#+BEGIN_SRC emacs-lisp
(require 'multi-term)
(setq multi-term-program "/usr/bin/fish")
#+END_SRC

For simplicity, I also add the =mterm= command to just call
=multi-term=.

#+BEGIN_SRC emacs-lisp
(defun mterm ()
  (interactive)
  (multi-term))
#+END_SRC

One annoyance is that the screen bounces in multi-term due to my
=scroll-margin=.  But there's a solution: file-local variables.  We
attach a handler to =term-mode-hook= that makes =scroll-margin= local
and then sets it to =0=.  Because =make-local-variable= returns the
variable (as a symbol), we can call =set= (that's right: not =setq=,
but =set=, since we already have the variable quoted for us) to set
it.

#+BEGIN_SRC emacs-lisp
(add-to-list 'term-mode-hook (lambda ()
  (set (make-local-variable 'scroll-margin) 0)))
#+END_SRC

* Pianobar

I currently use Pianobar to listen to my music. To do that from Emacs,
I use the wonderful [[http://www.emacswiki.org/emacs/pianobar.el][=pianobar.el=]].

#+BEGIN_SRC emacs-lisp
(autoload 'pianobar "pianobar" nil t)
#+END_SRC

I don't give it my password (since this =emacs.org= file goes
online...) but I do set my username and station.

#+BEGIN_SRC emacs-lisp
(setq pianobar-username "pavpanchekha@gmail.com")
(setq pianobar-station "2")
(defadvice pianobar (before query-password activate)
  "Queries me for my password to pianobar"
  ; Warning: purposely dynamic scoping!!!
  (setq pianobar-password (read-passwd "Pianobar password: ")))
#+END_SRC

* Meta

I actually edit my Emacs configuration a lot.  I call it "cultivating"
my Emacs configuration.  So here are some utility functions for that.

The first function just reloads the Emacs configuration.

#+BEGIN_SRC emacs-lisp
(defun reconfigure ()
  (interactive)
  (load-file "~/.emacs.d/init.el"))
#+END_SRC

The second function opens the configuration up for editing.

#+BEGIN_SRC emacs-lisp
(defun edconfigure ()
  (interactive)
  (find-file "~/.emacs.d/emacs.org"))
#+END_SRC
* Archive                                                           :ARCHIVE:

** Emacsclient configuration
   :PROPERTIES:
   :ARCHIVE_TIME: 2011-07-21 Thu 18:02
   :END:

I used to want =emacsclient= files to always open in a new buffer;
that way unenlightened tools like Firefox, which do not allow
arguments, can still have =emacsclient= set as their PDF viewer.
Nowadays, I use =emacsclient= in shell scripts, and then I do not want
more windows to pop open.  So I've archived this section of the scripts

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'server-switch-hook
          (lambda nil
            (let ((server-buf (current-buffer)))
              (bury-buffer)
              (switch-to-buffer-other-frame server-buf))))
#+END_SRC 

I used to have code to kill frames when the server is done with them,
but that became annoying with more advanced Emacs usage.

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'server-done-hook
          (lambda ()
            (delete-frame)
            (kill-buffer nil)))
#+END_SRC
