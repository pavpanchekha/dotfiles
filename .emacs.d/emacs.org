#+TITLE: Emacs Initialization Script

I use Org's [[http://orgmode.org/worg/org-contrib/babel/intro.html#sec-8_2][Babel system]] for this configuration file. My =.emacs.d/init.el= file contains only:

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (package-initialize)
  (require 'ob-tangle)
  (org-babel-load-file "~/.emacs.d/emacs.org")
#+END_SRC

* Packages

I use Emacs's package manager to install others' Emacs scripts and helpers. I install most packages from [[http://marmalade-repo.org/][Marmalade]], so I need to enable that repository.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
#+END_SRC

I'll be littering the rest of this file with package names, and I'll use this function to avoid re-installing packages.

#+BEGIN_SRC emacs-lisp
  (defun package-safe-install (&rest packages)
    (dolist (package packages)
      (unless (package-installed-p package)
        (package-install package))
      (require package)))
#+END_SRC

* Personal Information

My name and email address helps Emacs format various messages.

#+BEGIN_SRC emacs-lisp
  (setf user-full-name "Pavel Panchekha")
  (setf user-mail-address "me@pavpanchekha.com")
#+END_SRC

I keep my custom-set variables separate from my true configuration file.

#+BEGIN_SRC emacs-lisp
  (setf custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+END_SRC

Since I publish this file on the Internet, I keep my passwords elsewhere:

#+BEGIN_SRC emacs-lisp
(org-babel-load-file "~/.emacs.d/passwords.org")
#+END_SRC

I store some collected data in Dropbox. To avoid one computer overwriting another's data, I include the hostname in the file name. This code extracts the hostname itself.

#+BEGIN_SRC emacs-lisp
  (setf hostname
        (with-temp-buffer
          (call-process "hostname" nil t)
          (let ((hostname* (buffer-string)))
            (while (string-match "[\r\n\t ]+" hostname*)
              (setq hostname* (replace-match "" t t hostname*)))
            hostname*)))
#+END_SRC
* Graphical Interface Quirks

I'm believe in maximizing screen real estate, so I turn off the scroll bar and the tool bar.

Some things Emacs does by default just use up screen real estate and programmer patience.  Note that =tool-bar-mode= requires a *nonzero* parameter, not a truthy parameter, to display the toolbar.  This is absolutely absurd, but what can one do?

#+BEGIN_SRC emacs-lisp
  (set-scroll-bar-mode nil)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
#+END_SRC

Instead of the menu bar, I put the mode line at the top of the document (a trick I took from [[http://bzg.fr/emacs-strip-tease.html][Bastien Guerry]]):

#+BEGIN_SRC emacs-lisp
  (setq-default header-line-format mode-line-format)
  (setq-default mode-line-format nil)
#+END_SRC

Emacs also has an unnecessary startup screen which I inhibit.

#+BEGIN_SRC emacs-lisp
  (setf inhibit-startup-screen t
        inhibit-startup-message t
        inhibit-startup-echo-area-message t)
#+END_SRC

Instead, I would rather Emacs visit the =~= directory, in which I store current projects.

#+BEGIN_SRC emacs-lisp
  (setf initial-buffer-choice "~/")
#+END_SRC

The mode-line is made more useful by showing the column number and progress through the file.

#+BEGIN_SRC emacs-lisp
  (setf column-number-mode t)
  (setf size-indication-mode t)
#+END_SRC

I hate my computer beeping when I err. I ask Emacs to express its discontent visually.

#+BEGIN_SRC emacs-lisp
  (setf visible-bell t)
#+END_SRC

I rarely use the mouse, so tooltips are an annoyance.  This code causes them to appear in the echo area instead.

#+BEGIN_SRC emacs-lisp
  (tooltip-mode -1)
  (setf tooltip-use-echo-area t)
#+END_SRC

I use a [[https://github.com/cathywu/TimeTracker][time tracker]] that records window titles.  Thus I display the currently file path in the window title.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '((:eval (if (buffer-file-name)
                     (concat "Emacs: " (abbreviate-file-name (buffer-file-name)))
                   "Emacs: %b"))))
#+END_SRC

* Evil: key commands à la Vim

I use [[http://gitorious.org/evil/pages/Home][Evil]]; it is the Vim key-stroke language for Emacs.

#+BEGIN_SRC emacs-lisp
  (package-safe-install 'evil)
  (evil-mode 1)
#+END_SRC

By default Evil uses [[http://www.dr-qubit.org/undo-tree/undo-tree-0.6.4.el][undo-tree]], which represents previous document states as a tree. I, however, prefer the more confusing but simpler cyclic undo that comes with vanilla Emacs.

#+BEGIN_SRC emacs-lisp
  (global-undo-tree-mode -1)
#+END_SRC

I cause =RET= to automatically indent the new line. This tends to make sense in all modes except text; and in text mode it is usually not much of a bother.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC

Visual line mode creates proper visual line breaks without wrapping words. I use it often, so I ask Evil to count many commands in visual lines. The commands =I= and =A= should act similarly, but they do not yet have associated =-visual-line= versions.

#+BEGIN_SRC emacs-lisp
(define-key evil-motion-state-map "j" #'evil-next-visual-line)
(define-key evil-motion-state-map "k" #'evil-previous-visual-line)
(define-key evil-motion-state-map "$" #'evil-end-of-visual-line)
(define-key evil-motion-state-map "^" #'evil-first-non-blank-of-visual-line)
(define-key evil-motion-state-map "0" #'evil-beginning-of-visual-line)
#+END_SRC

* Auto-completion

The [[http://cx4a.org/software/auto-complete/][Auto Complete Mode]] provides self-effacing yet effective inline auto-completion.

#+BEGIN_SRC emacs-lisp
  (package-safe-install 'auto-complete)
#+END_SRC

Auto Complete Mode automatically enables itself in all buffers, so little configuration is really needed. I ask it to use fuzzy matching, which accounts for typos.

#+BEGIN_SRC emacs-lisp
  (setf ac-use-fuzzy t)
#+END_SRC

* For text documents

I also use Markdown and BibTeX for some files. Markdown has become a standard format for many in the open-source community. My BibTeX files contain commentaries and so are also text files in Org mode.

#+BEGIN_SRC emacs-lisp
  (package-safe-install 'markdown-mode)
#+END_SRC

For all of these I enable the variable-pitch and fly-spell modes. The first switches to a proportional font; the second spell-checks as I type (more below).

#+BEGIN_SRC emacs-lisp
  (dolist (hook '(markdown-mode-hook org-mode-hook))
    (add-hook 'org-mode-hook '(lambda () (setf cursor-type bar)))
    (add-hook hook 'variable-pitch-mode)
    (add-hook hook 'flyspell-mode))
#+END_SRC

I’ve gone back and forth on single- and double-spaced sentences, but for now I’m in the single-spacing camp.

#+BEGIN_SRC emacs-lisp
(setf sentence-end-double-space nil)
#+END_SRC

The visual-line mode implements proper line wrapping. I prefer to use this, but traditionally Markdown files are hard-wrapped. But when a window is very wide, wrapped text becomes unreadable. My [[https://github.com/pavpanchekha/center-text.el][center-text mode]] narrows the content to account for this.

#+BEGIN_SRC emacs-lisp
  (package-safe-install 'center-text)
  (setf center-text-default-width 58)

  (add-hook 'org-mode-hook 'visual-line-mode)
  (add-hook 'org-mode-hook 'center-text-mode)
  (add-hook 'markdown-mode-hook 'auto-fill-mode)
#+END_SRC

I give Org-mode files a =txt= extension because this allows editing them on other devices. As mentioned, my BibTeX files contain paper commentaries, so I set them to Org mode as well.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
(add-to-list 'auto-mode-alist '("\\.bib$" . org-mode))
#+END_SRC

In text documents I prefer matched punctuation. The =typopunct= package provides this.

#+BEGIN_SRC emacs-lisp
  (package-safe-install 'typopunct)
  (typopunct-change-language 'english t)
  (add-hook 'org-mode-hook 'typopunct-mode)
  (add-hook 'markdown-mode-hook 'typopunct-mode)
#+END_SRC


LaTeX documents get a similar treatment.

#+BEGIN_SRC emacs-lisp
  (add-hook 'latex-mode-hook 'flyspell-mode)
  (add-hook 'latex-mode-hook 'variable-pitch-mode)
  (add-hook 'latex-mode-hook 'auto-fill-mode)
  (add-hook 'org-mode-hook '(lambda () (setf cursor-type bar)))
#+END_SRC

* Org-mode

[[http://orgmode.org/][Org-mode]] is a suite of plain-text organization and authoring tools.

#+BEGIN_SRC emacs-lisp
  (package-safe-install 'org)
#+END_SRC

To make it easier to embed Unicode characters into Org-mode files, I turn on the TeX input mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda () (set-input-method 'TeX)))
#+END_SRC

Org-mode indents description lists so as to keep a consistent left edge. I don't like this behavior.

#+BEGIN_SRC emacs-lisp
  (setf org-description-max-indent 0)
#+END_SRC

I prefer to hide the inline markup used by Org-mode.

#+BEGIN_SRC emacs-lisp
  (setf org-hide-emphasis-markers t)
#+END_SRC

Org-mode needs more information to use alternate LaTeX document classes.  I put this information into a separate file so I can load it separately in Makefiles.

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/export.el")
#+END_SRC
* ISpell spell checker

Fly-spell mode uses ISpell. I want to use the =ispell= program, to use American English, and to locate my personal dictionary within my =.emacs.d= directory.

#+BEGIN_SRC emacs-lisp
(setf ispell-program-name "/usr/bin/ispell")
(setf ispell-dictionary "american")
(setf ispell-personal-dictionary "~/.emacs.d/dict")
#+END_SRC

A key binding I really miss from Vim is the spell checking keys =zg= and =z==.  Emacs has a great spell-check built-in: Ispell. All we need to do is add a few key-bindings.  But first we need a function to bind to, and for =zg=, one does not exist.  So off we go to implement =ispell-save-word.=

#+BEGIN_SRC emacs-lisp
(defun ispell-save-word () (interactive)
#+END_SRC

First, we need to *get* the current word.  We don't need to explicitly use =ispell-following-word=, since =ispell-get-word= does this for us. =ispell-get-word= returns a list of =word=, =start=, =end= (though its documentation certainly doesn't hint at such), so we call =car= to extract the word itself.

#+BEGIN_SRC emacs-lisp
  (let ((word (car (ispell-get-word nil))))
#+END_SRC

Now we can call =ispell-send-string=.  Its documentation is pretty weak (and that's if I want to be nice), but from reading the code of =ispell-command-loop= (search for =?i=), it seems like we want to send =*word\n=, where =word= is the word in question.

#+BEGIN_SRC emacs-lisp
  (ispell-send-string (concat "*" word "\n"))
#+END_SRC

Finally, since we modified the dictionary, we want to save it.  To be nice, we're going to first mark the dictionary as modified.  We only want to force a save, though, if the dictionary was clean before-hand, so we save the old value.

#+BEGIN_SRC emacs-lisp
  (let ((old-ispell-pdict-modified-p ispell-pdict-modified-p))
    (setq ispell-pdict-modified-p '(t))
#+END_SRC

And finally, we want force a save if necessary.  The "if necessary" part is actually annoyingly complicated...

#+BEGIN_SRC emacs-lisp
    (when (or (and old-ispell-pdict-modified-p
                   (listp old-ispell-pdict-modified-p)
                   (car ispell-pdict-modified-p))
              (and ispell-pdict-modified-p
                   (not (listp ispell-pdict-modified-p)))))
#+END_SRC

But once that's out of the way, we can just call =ispell-pdict-save= with =no-query=.

#+BEGIN_SRC emacs-lisp
      (ispell-pdict-save t))))
#+END_SRC

Finally, we add key-bindings using Evil's =evil-normal-state-map=.

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map "z=" 'ispell-word)
(define-key evil-normal-state-map "zg" 'ispell-save-word)
#+END_SRC

* Magit Git integration

[[http://magit.github.io/magit/][Magit]] is an incredible Emacs interface to the [[https://git-scm.com][Git version-control system]].

#+BEGIN_SRC emacs-lisp
  (package-safe-install 'magit)
#+END_SRC

Sadly, the theme I use has a bug with Magit, which I need to fix.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'magit-item-highlight nil :foreground "black")
#+END_SRC

* Miscellaneous

Emacs has some stupid defaults, such as making those =file~= files and using tabs for indentation.  I also make Emacs add final newlines and to prompt me for only single characters (why is that default?).

#+BEGIN_SRC emacs-lisp
(setf make-backup-files nil)
(setq-default indent-tabs-mode nil)
(setf require-final-newline t)
#+END_SRC

Also, I often have multiple buffers open with the same name.  Emacs
usually deals with this by appending the buffer number to the buffer
name.  This is hard to keep track of.  Instead, the =uniquify= library
uses the parent directory name, which I usually know.

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setf uniquify-buffer-name-style 'post-forward-angle-brackets)
#+END_SRC

For searching, I enable highlighting as-I-search for both searches and search/replaces.  Also, searches are made case-insensitive.

#+BEGIN_SRC emacs-lisp
(setf search-highlight t)
(setf query-replace-highlight t)
(setf case-fold-search t)
#+END_SRC emacs-lisp

For scrolling, I ask Emacs to scroll at most five lines at a time and to keep 5 lines between the cursor and the top/bottom of the page.

#+BEGIN_SRC emacs-lisp
(setf scroll-conservatively 5)
(setf scroll-margin 5)
#+END_SRC

When I write emacs-lisp I am often in the debugger. To turn it on, I use this function:

#+BEGIN_SRC emacs-lisp
  (defun debug-mode ()
    "Turn on various Emacs debugging features"
    (interactive)

    (setf debug-on-error t message-log-max 10000))
#+END_SRC

I'm also often "tending to" my Emacs configuration (this file). It's helpful to jump to it and reload it quickly.,

#+BEGIN_SRC emacs-lisp
(defun reconfigure () (interactive)
  (load-file "~/.emacs.d/init.el"))

(defun edconfigure () (interactive)
  (find-file "~/.emacs.d/emacs.org"))
#+END_SRC

* Navigating

[[https://github.com/bbatsov/projectile][Projectile]] is a project management suite for Emacs.

#+BEGIN_SRC emacs-lisp
  (package-safe-install 'projectile)
#+END_SRC

I enable it everywhere. It only does anything when I’m in a version-controlled directory, so there’s little harm in this.

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

* Haskell programming tools

[[https://github.com/haskell/haskell-mode][Haskell Mode]] provides syntax highlighting and similar utilities for programming in Haskell.

#+BEGIN_SRC emacs-lisp
  (package-safe-install 'haskell-mode)
#+END_SRC

Multiple methods of indenting Haskell code come with Haskell Mode. They don't differ much, but I prefer =haskell-indent=.

#+BEGIN_SRC emacs-lisp
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
#+END_SRC

* Scheme programming tools

Several modes come together to make programming in Scheme enjoyable. I usually use the Racket dialect of Scheme, but I've used MIT-Scheme heavily in the past. Sadly, no package seems to support both these dialects. For now I use [[http://www.neilvandyke.org/quack/][Quack]] and [[http://www.nongnu.org/geiser/][Geiser]], which together make Racket a breeze.

#+BEGIN_SRC
  (package-safe-install 'quack 'geiser)
#+END_SRC

Since I never use Guile, I configure Geiser to always start up in Racket mode.

#+BEGIN_SRC emacs-lisp
  (setf geiser-active-implementations '(racket))
#+END_SRC

It is customary in Racket to use a proper Unicode λ instead of the symbol =lambda=. I hack the abbreviation tools in Emacs to make this happen: I set =lambda= to be an abbreviation for =λ=.

#+BEGIN_SRC emacs-lisp
   (require 'abbrev)
   (add-hook 'scheme-mode-hook
     (lambda ()
       (abbrev-mode 1)
       (define-abbrev scheme-mode-abbrev-table "lambda" "λ")))
#+END_SRC

Perfectly matching parentheses is annoying; =electric-pair-mode= automatically inserts closing parentheses when I type the open parenthesis. I pair this with =show-paren-mode=, which automatically highlights the matching parenthesis.

#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook 'electric-pair-mode)
  (add-hook 'scheme-mode-hook 'show-paren-mode)
#+END_SRC

Geiser provides auto-completion with =M-TAB=; I prefer =TAB= do double-duty as indentation or completion.

#+BEGIN_SRC emacs-lisp
  (setf geiser-mode-smart-tab-p t)
#+END_SRC

Geiser stores history information; I'd prefer it not clutter my home directory.

#+BEGIN_SRC emacs-lisp
  (setf geiser-repl-history-filename "~/.emacs.d/geiser-history")
#+END_SRC

* Printing Buffers to PDF

I needed to print an Emacs buffer to PDF.  The standard printing commands rely on =lpr= and assume an actual printer. Instead I use the Emacs =printing= package to export buffers to Postscript, and then call =ps2pdf= to produce a PDF from the Postscript.

#+BEGIN_SRC emacs-lisp
(require 'printing)
#+END_SRC

We want to use the function =pr-ps-buffer-print= from the =printing= package.  We give it a temporary file to print to, and later we'll run =ps2pdf= on that file.

#+BEGIN_SRC emacs-lisp
  (defun print-to-pdf () (interactive)
    (let* ((outfile (make-temp-file pr-ps-temp-file))
           (pdffile (concat outfile ".pdf")))
      (pr-ps-buffer-print 1 outfile)
      (shell-command (concat "ps2pdf "
                             (shell-quote-argument outfile)
                             " "
                             (shell-quote-argument pdffile)))
      (find-file pdffile)))
#+END_SRC

The default print settings are silly for printing to PDF. I prefer syntax highlighting but no headers.

#+BEGIN_SRC emacs-lisp
  (setf pr-faces-p t)
  (setf ps-print-header nil)
  (setf ps-print-header-frame)
#+END_SRC
* The =run= Command

I have command called =run=, which compiles and runs some program or file in a temporary directory.  I use it for compiling LaTeX or testing C code.

#+BEGIN_SRC emacs-lisp
  (defun run-command (file)
    (interactive (list (buffer-file-name)))
    (save-window-excursion
     (shell-command (concat "run " file " &"))))

  (defun compile-command (file)
    (interactive (list (buffer-file-name)))
    (save-window-excursion
     (shell-command (concat "run -c " file " &"))))
#+END_SRC

Then we attach them to =[f5]= and =[C-f5]=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") 'run-command)
  (global-set-key (kbd "C-<f5>") 'compile-command)
#+END_SRC

* Shells

The Emacs shell mode is great, but barfs on ANSI escape sequence.  There's a quick fix:

#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+END_SRC

* Dropbox

[[http://github.com/pavpanchekha/dropbox.el/][dropbox.el]] is a Dropbox client I wrote -- it accesses files from Dropbox through the [[http://developers.dropbox.com][Dropbox API]].  It needs a bit of setup, mostly to set the API secret and key.  The actual values are in the [[file:passwords.org][passwords file]], but I unpack them here to remind myself that the entry in the passwords file exists.

#+BEGIN_SRC emacs-lisp
  (load "~/Dropbox/Work/dropbox.el/dropbox.el")
  (setf dropbox-consumer-key    (car  my-dropbox-key))
  (setf dropbox-consumer-secret (cadr my-dropbox-key))
#+END_SRC

Since I don't have many concurrent clients and rarely use shared folders, a longer cache time makes a lot of sense.

#+BEGIN_SRC emacs-lisp
  (setf dropbox-cache-timeout 300)
#+END_SRC

* Inter-Key Timings

One interesting characteristic of a person's typing is their inter-key timings -- the time between typing two letters in succession.  For example, it usually takes more time to type "cr" than ";l", since one involves moving the left index finger a large distance and the other uses the really natural rolling chord on the right hand.  By recording all key character pairs, we can actually track timings for this.  And since I do a lot of my work in Emacs, it is easiest to do this as an Emacs extension.  I've written such a thing: [[http://git.pavpanchekha.com/?p=keylogger.el.git;a=summary][keylogger.el]].  It has an Emacs Lisp extension and an analyzer written in Javascript.  Anyway, I'd like to turn it on when Emacs starts:

#+BEGIN_SRC emacs-lisp
  (load "~/Dropbox/Work/keylogger.el/keylogger.el")
  (setf keylogger-filename (concat "~/Dropbox/Data/keys." hostname ".el"))
  (keylogger-load)
  (keylogger-start)
  (keylogger-autosave)
#+END_SRC

Note that each startup, I load the file, load my previously-saved data, tell it to record new key presses, and to autosave them every fifteen minutes.

* Doc View

I generally use doc-vew for long PDFs, so I find it best to have continuous scrolling.

#+BEGIN_SRC emacs-lisp
  (setf doc-view-continuous t)
#+END_SRC

144 is a decent resolution, since it makes a page of text about as wide as half my screen (and I generally use Emacs with two vertical panes.

#+BEGIN_SRC emacs-lisp
  (setf doc-view-resolution 144)
#+END_SRC

Doc-view is in sore need of Vim-style h/j/k/l movement keys.

#+BEGIN_SRC emacs-lisp
  (require 'doc-view)
  (define-key doc-view-mode-map (kbd "j") 'doc-view-next-line-or-next-page)
  (define-key doc-view-mode-map (kbd "k") 'doc-view-previous-line-or-previous-page)
  (define-key doc-view-mode-map (kbd "h") 'image-backward-hscroll)
  (define-key doc-view-mode-map (kbd "l") 'image-forward-hscroll)
#+END_SRC
