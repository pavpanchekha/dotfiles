#+TITLE: Emacs Initialization Script

All of my Emacs initialization is contained within this one Literate
Babel file.  I use the Babel system in Org-mode to evaluate the code
within on Emacs startup, which lets me write nice descriptive text for
my code.  My =.emacs.d/init.el= file contains only:

: (require 'org-install)
: (require 'ob-tangle)
: (org-babel-load-file "~/.emacs.d/emacs.org")

More on this method can be found [[http://orgmode.org/worg/org-contrib/babel/intro.html#sec-8_2][in the Babel tutorial]].

* Packages

  My Emacs configuration relies on several packages being installed,
  in particular various modes.  Now that Emacs has a package manager
  built in, I've changed the names to those names.

  + evil        :: A good text editor for Emacs
  + org         :: Organization and markup system.
  + multi-term  :: Emacs =term= is impossible.  This is not.
  + magit       :: =git= in Emacs


  A few language modes are also there: =erlang=, =go-mode=,
  =haskell-mode=, =markdown-mode=, =mediawiki=.

  I also use several packages from the Arch AUR, which aren't yet
  available on the package repos.

  + emacs-w3m-cvs      :: browse the web in Emacs.

  These packages are, in general, loaded from the =package.el= package
  manager.  In particular, we use the Marmalade repository on top of
  the GNU-maintained one, which gives us access to quite a few tools.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
  (package-initialize)
#+END_SRC

* Miscellany
** Startup

Emacs might as well know my name and email address.  I trust it.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Pavel Panchekha")
(setq user-mail-address "me@pavpanchekha.com")
#+END_SRC

Also, I like to keep my custom-set variables from polluting my other
files, so I like to move the =custom-file=.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

Finally, since I publish this file on the Internet, I don't want
passwords in it.  So I keep them elsewhere, and load them here:

#+BEGIN_SRC emacs-lisp
(org-babel-load-file "~/.emacs.d/passwords.org")
#+END_SRC

** GUI Settings

Some things Emacs does by default just use up screen real estate and
programmer patience.  Note that =tool-bar-mode= requires a *nonzero*
parameter, not a truthy parameter, to display the toolbar.  This is
absolutely absurd, but what can one do?

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message t)
(set-scroll-bar-mode nil)
(tool-bar-mode 0)
#+END_SRC

I'm not yet pro enough to forsake =menu-bar-mode=, though one day I'll
get there.

Also, I like knowing where my files end; ergo I ask Emacs to show
empty lines.

#+BEGIN_SRC emacs-lisp
(if (not indicate-empty-lines)
  (toggle-indicate-empty-lines))
#+END_SRC

The modeline should really be pressed into useful service.  I make it
display the time, and for the position display, have it give the column
number and file size:

#+BEGIN_SRC emacs-lisp
(display-time-mode t)
(setq column-number-mode t)
(setq size-indication-mode t)
#+END_SRC

The =yes or no= prompts get annoying quickly.  Instead, we ask Emacs to
use single-character responses

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Whenever I do something that Emacs finds odd, it beeps.  Why?  Who
knows.  In any case, I turn it off, because when I'm lounging about
with music on the overhead speakers, I don't want a beep interfering.

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

Since I rarely use the mouse, tooltips are more an annoyance than
anything else.  This switches them to appear in the echo area.

#+BEGIN_SRC emacs-lisp
(tooltip-mode -1)
(setq tooltip-use-echo-area t)
#+END_SRC

I'm old enough for no training wheels.  Narrowing a buffer hides
certain text, which is nice for focusing and buffer-cloning magic.

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** Visual Line Mode Hacks

I like using visual-line-mode, especially when editing text.  But this is problematic if the width of the window is very large, since in that case the line doesn't wrap until it is 100 or so characters long.  To fix this, I use the following function:

#+BEGIN_SRC emacs-lisp
  (defun center-within (max-chars)
    "Expand or shrink the fringe until the text width is
  MAX-CHARS characters or fewer characters wide or less"
    (interactive "p")
    (while (not (or (= (window-width) max-chars)
                    (and (< (window-width) max-chars)
                         (= (car (window-fringes)) 0))))
      (let ((char-width
             (* (aref (font-info (face-font 'default)) 2) (/ 1.0 12.0) 6.0))
            (current-chars
             (window-width))
            (current-fringe
             (cons (car (window-fringes)) (cadr (window-fringes)))))
        (let* ((excess-chars (- current-chars max-chars))
               (excess-width (* excess-chars char-width))
               (deficit-margin (floor (/ excess-width 2)))
               (left-fringe (max 0 (+ (car current-fringe) deficit-margin)))
               (right-fringe (max 0 (+ (cdr current-fringe) deficit-margin))))
          (set-window-fringes nil left-fringe right-fringe)))))
#+END_SRC

Eventually I should make this a minor mode with redisplays keyed off =window-size-change-functions=, but for now I'll hold off on this next step.

** Basic File Behaviors

Emacs has some stupid defaults, such as making those =file~= files and
using tabs for indentation.  I also make Emacs add final newlines and
to prompt me for only single characters (why is that default?).

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq-default indent-tabs-mode nil)
(setq require-final-newline t)
#+END_SRC

Also, I often have multiple buffers open with the same name.  Emacs
usually deals with this by appending the buffer number to the buffer
name.  This is hard to keep track of.  Instead, the =uniquify= library
uses the parent directory name, which I usually know.

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'post-forward-angle-brackets)
#+END_SRC

** Games

It's very important that score files are placed correctly (can't lose
my tetris high scores!):

#+BEGIN_SRC emacs-lisp
(setq tetris-score-file "~/.emacs.d/scores/tetris")
(setq snake-score-file  "~/.emacs.d/scores/snake")
#+END_SRC

** Utility Libraries

I like =(loop)= and extended argument lists, so I need the =cl=
library.

#+BEGIN_SRC emacs-lisp
(require 'cl)
#+END_SRC

* Key Bindings
** Vim Key Bindings

We use the [[http://gitorious.org/evil/pages/Home][Evil package]] for Vim keybindings in Emacs.

#+BEGIN_SRC emacs-lisp
  (require 'evil)
  (evil-mode 1)
#+END_SRC

** Ispell =ispell-save-word=

Another key binding I really miss from Vim is the spelling key
bindings =zg= and =z==; these make spell-checking much nicer to use.
Emacs has a great spell-check built-in: Ispell.  All we need to do is
add a few key-bindings.  But first we need a function to bind to, and
for =zg=, one does not exist.  So off we go to implement
=ispell-save-word.=

#+BEGIN_SRC emacs-lisp
(defun ispell-save-word ()
  (interactive)
#+END_SRC

First, we need to *get* the current word.  We don't need to explicitly
use =ispell-following-word=, since =ispell-get-word= does this for us.
=ispell-get-word= returns a list of =word=, =start=, =end= (though its
documentation certainly doesn't hint at such), so we call =car= to
extract the word itself.

#+BEGIN_SRC emacs-lisp
  (let ((word (car (ispell-get-word nil))))
#+END_SRC

Now we can call =ispell-send-string=.  Its documentation is pretty
weak (and that's if I want to be nice), but from reading the code of
=ispell-command-loop= (search for =?i=), it seems like we want to send
=*word\n=, where =word= is the word in question.

#+BEGIN_SRC emacs-lisp
  (ispell-send-string (concat "*" word "\n"))
#+END_SRC

Finally, since we modified the dictionary, we want to save it.  To be
nice, we're going to first mark the dictionary as modified.  We only
want to force a save, though, if the dictionary was clean before-hand,
so we save the old value.

#+BEGIN_SRC emacs-lisp
  (let ((old-ispell-pdict-modified-p ispell-pdict-modified-p))
    (setq ispell-pdict-modified-p '(t))
#+END_SRC

And finally, we want force a save if necessary.  The "if necessary"
part is actually annoyingly complicated...

#+BEGIN_SRC emacs-lisp
    (when (or (and old-ispell-pdict-modified-p
                   (listp old-ispell-pdict-modified-p)
                   (car ispell-pdict-modified-p))
              (and ispell-pdict-modified-p
                   (not (listp ispell-pdict-modified-p)))))
#+END_SRC

But once that's out of the way, we can just call =ispell-pdict-save=
with =no-query=.

#+BEGIN_SRC emacs-lisp
      (ispell-pdict-save t))))
#+END_SRC

Finally, we add key-bindings using Evil's =evil-normal-state-map.

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map "z=" 'ispell-word)
(define-key evil-normal-state-map "zg" 'ispell-save-word)
#+END_SRC

** Visual Line Mode hacks

I like to use visual line mode for text files (more semantic
information!), so I have the following hack for Evil:

#+BEGIN_SRC emacs-lisp
(define-key evil-motion-state-map "j" #'evil-next-visual-line)
(define-key evil-motion-state-map "k" #'evil-previous-visual-line)
(define-key evil-motion-state-map "$" #'evil-end-of-visual-line)
(define-key evil-motion-state-map "^" #'evil-first-non-blank-of-visual-line)
(define-key evil-motion-state-map "0" #'evil-beginning-of-visual-line)
#+END_SRC

Note that these work fine in hard-wrapped text, too; they're
just not as necessary.  Also note that commands like =I= and =A=
should in theory also receive this treatment, but alas, they
don't have associated =-visual-line= versions.

** Miscellaneous

I prefer to work with indented text at all times, so =RET= should be
bound to =newline-and-indent=, and some terminals have problems with
the delete key or something, so I keep the following bindings around
as well.  The last line there make =C-k= kill the whole line.

#+BEGIN_SRC emacs-lisp
(global-set-key [C-m] 'newline-and-indent)
(global-set-key [delete] 'delete-char)
(setq kill-whole-line t)
#+END_SRC

** Searching and Scrolling

For searching, I enable highlighting as-I-search for both searches and
search/replaces.  Also, searches are made case-insensitive.

#+BEGIN_SRC emacs-lisp
(setq search-highlight t)
(setq query-replace-highlight t)
(setq case-fold-search t)
#+END_SRC emacs-lisp

For scrolling, I ask Emacs to scroll at most five lines at a time and
to keep 5 lines between the cursor and the top/bottom of the page.

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 5)
(setq scroll-margin 5)
#+END_SRC

** Showing my To Do list

   My To Do list opens with the actual list on the left and the agenda
   and the per-project todos on the right

#+BEGIN_SRC emacs-lisp
  (defun show-todo ()
    (interactive)
    (find-file "~/notes/pavel.txt")
    (org-agenda-list)
    (split-window-vertically)
    (other-window 1)
    (find-file "~/notes/projects.txt"))
#+END_SRC

* Utility Commands
** Debugging

Every once in a while, I develop in emacs-lisp, and make use of the
following:

#+BEGIN_SRC emacs-lisp
  (defun debug-mode ()
    "Turn on various Emacs debugging features"
    (interactive)

    (setf debug-on-error t message-log-max 10000))
#+END_SRC

** =run= Command

I have a =run= command that I rather like; it compiles and runs some
program or file in a temporary program.  I use it for, for example,
compiling LaTeX, or testing C code.

#+BEGIN_SRC emacs-lisp
  (defun run-command (file)
    (interactive (list (buffer-file-name)))
    (save-window-excursion
     (shell-command (concat "run " file " &"))))

  (defun compile-command (file)
    (interactive (list (buffer-file-name)))
    (save-window-excursion
     (shell-command (concat "run -c " file " &"))))
#+END_SRC

hThen we attach them to =[f5]= and =[C-f5]=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f5>") 'run-command)
(global-set-key (kbd "C-<f5>") 'compile-command)
#+END_SRC

** Printing to PDF

Sometimes, I need to print an Emacs buffer to PDF.  The standard
printing commands are less than ideal for this, since they rely on
=lpr=, a program I have no interest in installing and configuring.
Instead, I can use the Emacs =printing= package, which can export
buffers to Postscript, and then call =ps2pdf= to produce a PDF from
the Postscript.

First, I =require= in the =printing= package and ask it to install
itself into the Emacs menu tree.

#+BEGIN_SRC emacs-lisp
(require 'printing)
#+END_SRC

Now we write a function to print the current buffer.

#+BEGIN_SRC emacs-lisp
(defun print-to-pdf ()
  (interactive)
#+END_SRC

We want to use the function =pr-ps-buffer-print= from the =printing=
package.  We give it a temporary file to print to, and later we'll
=ps2pdf= that file.

#+BEGIN_SRC emacs-lisp
  (let* ((outfile (make-temp-file pr-ps-temp-file))
         (pdffile (concat outfile ".pdf")))
    (pr-ps-buffer-print 1 outfile)
    (shell-command (concat "ps2pdf "
                           (shell-quote-argument outfile)
                           " "
                           (shell-quote-argument pdffile)))
    (find-file pdffile)))
#+END_SRC

The default print settings are silly, especially once you consider
that my use case is print-to-PDF.  So I would rather print with syntax
highlighting and no headers.

#+BEGIN_SRC emacs-lisp
(setq pr-faces-p t
      ps-print-header nil
      ps-print-header-frame)
#+END_SRC

** Configuration editing configuration

I actually edit my Emacs configuration a lot.  I call it "cultivating"
my Emacs configuration.  So here are some utility functions for that.

The first function just reloads the Emacs configuration.

#+BEGIN_SRC emacs-lisp
(defun reconfigure ()
  (interactive)
  (load-file "~/.emacs.d/init.el"))
#+END_SRC

The second function opens the configuration up for editing.

#+BEGIN_SRC emacs-lisp
(defun edconfigure ()
  (interactive)
  (find-file "~/.emacs.d/emacs.org"))
#+END_SRC

** Key-map commands

Since I like Vim key-bindings everywhere, I'll be doing a lot of
adding to key-maps.  This gets tedious, especially when lots of keys
on the same key-map.  This macro makes adding a bunch of keys to the
same key-map very easy.

#+BEGIN_SRC emacs-lisp
  (defmacro define-keys (map &rest keys)
    "Adds several key bindings to a specific map.  Takes a map (as
    a bare symbol) and a several clauses of form (key func); key is
    a string to be passed to (kbd), and func is a function name."
    (declare (indent defun))

    `(progn
       ,@(loop for key+func in keys
               collect `(define-key ,map
                          (kbd ,(car key+func))
                          ',(cadr key+func)))))
#+END_SRC

* Doc-View

I generally use doc-vew for long PDFs, so I find it best to have
continuous scrolling.

#+BEGIN_SRC emacs-lisp
(setq doc-view-continuous t)
#+END_SRC

144 is a decent resolution, since it makes a page of text about as
wide as half my screen (and I generally use Emacs with two vertical
panes.

#+BEGIN_SRC emacs-lisp
(setq doc-view-resolution 144)
#+END_SRC

The PDF viewer is in sore need of Vim-style h/j/k/l movement keys

#+BEGIN_SRC emacs-lisp
(require 'doc-view)
(define-keys doc-view-mode-map
    ("j" doc-view-next-line-or-next-page)
    ("k" doc-view-previous-line-or-previous-page)
    ("h" image-backward-hscroll)
    ("l" image-forward-hscroll))
#+END_SRC

* Mode-specific Behaviors
** Text-like Modes

Since I like Org-mode so much, I feel it should be default for text
files.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
#+END_SRC

Other modes I use quite a bit are Restructured Text (for writing
Python code) and $\LaTeX$ (for class):

#+BEGIN_SRC emacs-lisp
(defun text-minor-modes ()
  (interactive)
  (visual-line-mode 1)
  (flyspell-mode 1))

(add-hook 'latex-mode-hook 'text-minor-modes)
(add-hook 'markdown-mode-hook 'text-minor-modes)
(add-hook 'org-mode-hook   'text-minor-modes)
#+END_SRC

Of course, if we're activating ISpell, we should set it up.  Firstly
we want to tell it to use =ispell=, to check spelling against American
English, and where my dictionary is.

#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "/usr/bin/ispell")
(setq ispell-dictionary "american")
(setq ispell-personal-dictionary "~/.emacs.d/dict")
#+END_SRC

LaTeX also could use a quick tool to compile and view a source file.
I use the =compile= command for this.

#+BEGIN_SRC emacs-lisp
  (defun latex-compile (file)
    (interactive (list (buffer-file-name)))

    (make-local-variable 'latex-compile-outfile)

    (let ((first-run (not (boundp 'latex-compile-outfile))))
      (when (or first-run (not (get-file-buffer latex-compile-outfile)))
        (setf latex-compile-outfile
              (make-temp-file "emacs-latex-compile-" nil ".pdf"))
        (setf first-run t))

      (save-window-excursion
        (shell-command (concat "run -c " file " -o " latex-compile-outfile)))

      (if first-run
          (find-file-other-window latex-compile-outfile)
        (progn
          (set-buffer (get-file-buffer latex-compile-outfile))
          (doc-view-revert-buffer t t)))))
#+END_SRC

** Language Modes

Some modes I just need to =(require)= in.  First, =load-path= need
setting up.

#+BEGIN_SRC emacs-lisp
(setq load-path
      (append load-path
              '("/usr/share/emacs/site-lisp/clojure-mode"
                "/usr/share/emacs/site-lisp/haskell-mode")))
#+END_SRC

Now we can require in the Haskell and Clojure modes.

#+BEGIN_SRC emacs-lisp
(require 'haskell-mode nil t)
(require 'clojure-mode nil t)
#+END_SRC

* Org Mode

We first include Org mode, and tell it which modules to use.

#+BEGIN_SRC emacs-lisp
(require 'org-install)
#+END_SRC

First things first!  We should set up the file structure.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/notes/")
(setq org-default-notes-file (concat org-directory "pavel.txt"))
#+END_SRC

Let's throw in a very minor editing thing (hitting =M-RET= shouldn't
split a bullet point in two).

#+BEGIN_SRC emacs-lisp
(setq org-M-RET-may-split-line '((default)))
#+END_SRC

Finally, Org-mode has this odd love of indenting the entries in
description lists so that there is a consistent left edge.  I don't
like it, and luckily I can turn it off.

#+BEGIN_SRC emacs-lisp
(setq org-description-max-indent 0)
#+END_SRC

** Agenda View

I use the agenda view a lot, so I customize it a bit.  The agenda
should show two days (including, yes, the ones without events); it
shouldn't show me things I've done; and I won't worry about starting
on a weekend or weekday.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-ndays 1)
  (setq org-agenda-span 2)
  (setq org-deadline-warning-days 3)

  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-start-on-weekday nil)
#+END_SRC

Since all of my TODO entries are in one file, I don't need the agenda
view to tell me what file a TODO entry comes from.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-file-regexp "\\`[^.].*\\.\\(txt\\|org\\)\\'")
  (setq org-agenda-files '("~/notes/"))
  (setq org-agenda-prefix-format
        '((agenda . " %i %?-12t% s")
          (timeline . "  % s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
#+END_SRC

Finally, given my use of the TODO list, I would like fewer deadline
reminders and more scheduled reminders

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown nil)
#+END_SRC

** Todo Keywords

The keywords here represent a good chunk of possible work-flows.  TODO
to DONE is the standard one, but sometimes I go to WONT or spent time
cycling between TODO and WAIT.  SOMEDAY exists for the projects that
I'd like to do, but that are currently in limbo.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "SOMEDAY(s)" "|" "DONE(d)" "WAIT(w)" "WONT(n)")))
(setq org-use-fast-todo-selection t)
#+END_SRC

** Entities
Since I use things like \RR so often, I made them into entities, so that
Org can typeset them nicely.

#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t
        org-entities-user '(; Double-struck letters for various fields
                            ("CC" "\\CC" t "&#8450;" "C" "C" "ℂ")
                            ("FF" "\\FF" t "&#120125;" "F" "F" "𝔽")
                            ("HH" "\\HH" t "&#8461;" "H" "H" "ℍ")
                            ("NN" "\\NN" t "&#8469;" "N" "N" "ℕ")
                            ("PP" "\\PP" t "&#8473;" "P" "P" "ℙ")
                            ("QQ" "\\QQ" t "&#8474;" "Q" "Q" "ℚ")
                            ("RR" "\\RR" t "&#8477;" "R" "R" "ℝ")
                            ("ZZ" "\\ZZ" t "&#8484;" "Z" "Z" "ℤ")

                            ; Fraktur letters for ideals
                            ("ga" "\\ga" t "&#120094;" "a" "a" "𝔞")
                            ("gb" "\\gb" t "&#120095;" "b" "b" "𝔟")
                            ("gc" "\\gc" t "&#120096;" "c" "c" "𝔠")
                            ("gd" "\\gd" t "&#120097;" "d" "d" "𝔡")
                            ("gm" "\\gm" t "&#120106;" "m" "m" "𝔪")
                            ("gn" "\\gn" t "&#120107;" "n" "n" "𝔫")
                            ("go" "\\go" t "&#120108;" "o" "o" "𝔬")
                            ("gp" "\\gp" t "&#120109;" "p" "p" "𝔭")
                            ("gq" "\\gq" t "&#120110;" "q" "q" "𝔮")

                            ; Miscellaneous mathematical
                            ("setminus" "\\setminus" t "&#8726;" "\" "\" "∖")
                            ("mapsto"   "\\mapsto" t "&#8614;" "|->" "|->" "↦")
                            ))
#+END_SRC

I also would rather hide the stars and such that org-mode uses for
inline markup:

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

** Key bindings

Some key bindings are not bound by Org automatically, so I have to bind
them myself.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
#+END_SRC

** LaTeX Export

Org-mode requires you to define things to use other classes for LaTeX
files.  I put this in a separate file so I can avoid loading it when
I'm just exporting.

#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/export.el")
#+END_SRC

* Magit

Magit needs a =(require)= and an autoload.

#+BEGIN_SRC emacs-lisp
(autoload 'magit-status "magit" nil t)
#+END_SRC

* W3M Browser

W3M is a nice web browser to use for tasks such as reading Hacker
News.  If it got a bit more love, it would be perfect...

#+BEGIN_SRC emacs-lisp
  (require 'w3m-load)
#+END_SRC

First off, W3M should use UTF8 everywhere it can.

#+BEGIN_SRC emacs-lisp
  (setq w3m-coding-system 'utf-8
        w3m-default-coding-system 'utf-8
        w3m-file-coding-system 'utf-8
        w3m-file-name-coding-system 'utf-8
        w3m-terminal-coding-system 'utf-8)
#+END_SRC

I change a few file locations.

#+BEGIN_SRC emacs-lisp
  (setq w3m-default-save-directory "/tmp/")
  (setq w3m-icon-directory "/tmp/")
#+END_SRC

W3M has some features that are, for whatever reason, off by default
(they're /experimental/; eh, work fine).

#+BEGIN_SRC emacs-lisp
  (setq w3m-use-cookies t w3m-use-favicon t)
#+END_SRC

Finally I set up my homepage.

#+BEGIN_SRC emacs-lisp
  (setq w3m-home-page "about:blank")
#+END_SRC

** Default Browsers

I prefer to set Firefox as Emacs's default browser, simply because
there are lots of sites W3M just doesn't work that well on.

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-firefox)
(setq browse-url-generic-program "google-chrome")
#+END_SRC

However, I still like the ability to throw open W3M easily.

#+BEGIN_SRC emacs-lisp
(autoload 'w3m-browse-url "w3m" "Ask a WWW browser to show a URL." t)
#+END_SRC

So I make a quick keybinding for browsing a URL.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-xm" 'browse-url-at-point)
(global-set-key "\C-xM" 'w3m-browse-url-at-point)
#+END_SRC

** Utility Commands

I prefer there to be a key to enter a new URL, blank-slate.

#+BEGIN_SRC emacs-lisp
  (defun w3m-clean-slate-goto-url (url)
    (interactive (list (w3m-input-url nil "" nil nil 'feeling-lucky)))
    (w3m-goto-url url))
#+END_SRC

The symmetric operations should clearly exist for tabs.

#+BEGIN_SRC emacs-lisp
  (defun w3m-clean-slate-goto-url-new-session (url)
    (interactive (list (w3m-input-url nil "" nil nil 'feeling-lucky)))
    (w3m-goto-url-new-session url))
#+END_SRC

Unfortunately, the open-in-new-tab command switches to the new tab
right away; this is silly.

#+BEGIN_SRC emacs-lisp
  (defun w3m-view-this-url-new-session-background ()
    "Display the page of the link under point in a new session, in
  the background. If the region is active, use the
  `w3m-open-all-links-in-new-session' command instead."
    (interactive)

    (save-window-excursion
      (call-interactively 'w3m-view-this-url-new-session)))
#+END_SRC

** Key-bindings

I like single-character key bindings instead of the crazy Emacs stuff.
Most of the following are following Vimperator/Vimium conventions.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "w3m"
    '(define-keys w3m-mode-map
       ("f" w3m-view-this-url)
       ("F" w3m-view-this-url-new-session-background)
       ("o" w3m-clean-slate-goto-url)
       ("O" w3m-goto-url)
       ("H" w3m-view-previous-page)
       ("L" w3m-view-next-page)
       ("t" w3m-clean-slate-goto-url-new-session)
       ("T" w3m-goto-url-new-session)
       ("d" w3m-delete-buffer)
       ("r" w3m-reload-this-page)
       (">" w3m-next-buffer)
       ("<" w3m-previous-buffer)
       ("/" isearch-forward)))
#+END_SRC

When a tab is closed, W3M should shift to the right tab, not the left tab.

#+BEGIN_SRC emacs-lisp
  (defun clamp (a n)
    (cond
     ((< a 0) 0)
     ((> a n) n)
     (t a)))

  (defun w3m-clamp-next-buffer (arg)
    "Turn ARG pages of emacs-w3m buffers ahead."
    (interactive "p")
    (unless arg (setq arg 1))
    (when (and (/= arg 0) (eq major-mode 'w3m-mode))
      (w3m-history-store-position)
      (let* ((buffers (w3m-list-buffers))
         (len (length buffers)))
        (switch-to-buffer
         (nth (clamp (+ arg (- len (length (memq (current-buffer) buffers))))
           len)
          buffers)))
      (w3m-history-restore-position)
      (run-hooks 'w3m-select-buffer-hook)
      (w3m-select-buffer-update)))

  (add-hook 'w3m-delete-buffer-hook (lambda () (w3m-clamp-next-buffer 1)))

#+END_SRC

* Mu For Emacs

I'm now reading my mail in =mu4e=, from the =mu-git= Arch Linux package.
This package is a lot like =notmuch= in that it's search-based and
works well with =offlineimap=, but has a much nicer interface and tries
very hard to stay compatible with the upstream IMAP folder.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
(require 'mu4e)
#+END_SRC

I need to tell Mu which folders store what on my system.  Note that I
only sync "important" messages with GMail to my system, so the
archive folder is the "important" folder.

#+BEGIN_SRC emacs-lisp
  (setf mu4e-maildir "~/mail"
        mu4e-sent-folder "/sent"
        mu4e-drafts-folder "/drafts"
        mu4e-trash-folder "/trash"
        mu4e-refile-folder "/important")
  (setf mu4e-attachment-dir  "/tmp")
#+END_SRC

Mail is synced with =offlineimap=, so I tell Mu to run that to get new
mail.  OfflineIMAP will automatically run the Mu indexer.

#+BEGIN_SRC emacs-lisp
  (setf mu4e-get-mail-command "offlineimap -o -u quiet")
#+END_SRC

Finally, since I'm using GMail, GMail will automatically deal with
filing sent messages, so I can tell Mu to just delete sent messages.

#+BEGIN_SRC emacs-lisp
  (setf mu4e-sent-messages-behavior 'delete)
#+END_SRC

In all of the =mu4e= modes, I want the Evil extensions off, since they
do naught but get in the way.  But somehow, this doesn't work for
=mu4e-view-mode=, so we use a special dispension for that.

#+BEGIN_SRC emacs-lisp
  (setf evil-emacs-state-modes (list* 'mu4e-headers-mode 'mu4e-main-mode
                                      'mu4e-main-mode 'mu4e-view-mode
                                      evil-emacs-state-modes))
  (add-hook 'mu4e-view-mode-hook 'evil-emacs-state)
#+END_SRC

There're a few graphical things to change about Mu4e:

#+BEGIN_SRC emacs-lisp
  (setf mu4e-use-fancy-chars t)
  (setf mu4e-view-show-images t)
#+END_SRC

** Sending mail

My mail gets sent through the GMail IMAP server. I used to use msmtp for sending mail, but I’ve now switched to using smtpmail.el, since it’s nice to have an Emacs-native solution.

#+BEGIN_SRC emacs-lisp
(setq send-mail-function 'smtpmail-send-it)
(setq message-send-mail-function 'smtpmail-send-it)
#+END_SRC

We now set up SMTPMail to use GMail.

#+BEGIN_SRC emacs-lisp
(setq smtpmail-smtp-server "smtp.gmail.com")
(setq smtpmail-smtp-service 587)
#+END_SRC

We then set up TLS for GMail’s connection:

#+BEGIN_SRC emacs-lisp
  (setq smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil)))
  (setq smtpmail-auth-credentials `(("smtp.gmail.com" 587
                                     "me@pavpanchekha.com" ,my-gapps-password)))
  (setq smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        smtpmail-local-domain "pavpanchekha.com")
#+END_SRC

** Bookmarks

I have a few bookmarks that set up my email flow.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'mu4e-bookmarks
    '("flag:unread AND maildir:/important"  "Important New Messages" ?i))
#+END_SRC

* Shells
** Eshell

Eshell doesn't actually require that much prodding.  The only thing I
do is change its directory.

#+BEGIN_SRC emacs-lisp
  (setq eshell-directory-name "~/.emacs.d/eshell/")
#+END_SRC

Eshell has an awesome "smart mode" where it emulates Plan 9 by
allowing you to edit command lines instead of re-executing them.  Here
I tell Eshell to not review commands that successfully exit, since
those are normally easy to re-execute anyways.

#+BEGIN_SRC emacs-lisp
  (require 'eshell)
  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)
#+END_SRC

Eshell lets you redirect to a buffer with the syntax

: cmd >> #<buffer *scratch*>

or to Elisp variables with

: cmd > #'adsf

Since I don't expect to use the second feature at all, I'd prefer its
syntax be used for buffer redirections instead.

#+BEGIN_SRC emacs-lisp
  (setq eshell-buffer-shorthand t)
#+END_SRC

** Multi-term

Multiterm requires a bit more setup.

#+BEGIN_SRC emacs-lisp
(require 'multi-term)
(setq multi-term-program "/bin/bash")
#+END_SRC

For simplicity, I also add the =mterm= command to just call
=multi-term=.

#+BEGIN_SRC emacs-lisp
(defun mterm ()
  (interactive)
  (multi-term))
#+END_SRC

One annoyance is that the screen bounces in multi-term due to my
=scroll-margin=.  But there's a solution: file-local variables.  We
attach a handler to =term-mode-hook= that makes =scroll-margin= local
and then sets it to =0=.  Because =make-local-variable= returns the
variable (as a symbol), we can call =set= (that's right: not =setq=,
but =set=, since we already have the variable quoted for us) to set
it.

#+BEGIN_SRC emacs-lisp
(add-to-list 'term-mode-hook (lambda ()
  (set (make-local-variable 'scroll-margin) 0)))
#+END_SRC

* Personal Analytics
** Inter-Key Timings

One interesting characteristic of a person's typing is their inter-key
timings -- the time between typing two letters in succession.  For
example, it usually takes more time to type "cr" than ";l", since one
involves moving the left index finger a large distance and the other
uses the really natural rolling chord on the right hand.  By recording
all key character pairs, we can actually track timings for this.  And
since I do a lot of my work in Emacs, it is easiest to do this as an
Emacs extension.  I've written such a thing: [[http://git.pavpanchekha.com/?p=keylogger.el.git;a=summary][keylogger.el]].  It has an
Emacs Lisp extension and an analyzer written in Javascript.  Anyway,
I'd like to turn it on when Emacs starts:

#+BEGIN_SRC emacs-lisp
(load "~/dev/keylogger.el/keylogger.el")
(load-every-key-press)
(remember-every-key-press)
(autosave-every-key-press)
#+END_SRC

Note that each startup, I load the file, load my previously-saved
data, tell it to record new key presses, and to autosave them every
fifteen minutes.
