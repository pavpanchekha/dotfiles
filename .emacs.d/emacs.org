#+TITLE: Emacs Initialization Script

I use Org's [[http://orgmode.org/worg/org-contrib/babel/intro.html#sec-8_2][Babel system]] for this configuration file. My =.emacs.d/init.el= file contains only:

#+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el"
  (package-initialize)
  (require 'ob-tangle)
  (org-babel-load-file "~/.emacs.d/emacs.org")
#+END_SRC

Since I publish this file on the Internet, I keep my passwords elsewhere:

#+BEGIN_SRC emacs-lisp
  (org-babel-load-file "~/.emacs.d/passwords.org")
#+END_SRC

* Packages

I install packages mostly from MELPA.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

Here are the packages I use; this table is [[http://sachachua.com/blog/2015/01/getting-data-org-mode-tables/][used by org-mode]] to install the packages.

#+NAME: packages
| Package         | Use                                      |
|-----------------+------------------------------------------|
| better-defaults | Hide menus and fix some basic annoyances |
| evil            | Vim key-bindings                         |
| evil-leader     | Set =SPC= as a leader key                  |
| ivy             | A generic tab completion Emacs plugin    |
| counsel         | Find-file for Ivy                        |
| magit           | A git mode                               |
| company         | Completions and suggestions              |
| org             | An organization tool                     |
| racket-mode     | Editing Racket code                      |
| vterm           | For running amp and maybe others         |

#+BEGIN_SRC emacs-lisp :var packages=packages
  (dolist (package (mapcar #'intern (mapcar #'car (cdr packages))))
    (unless (package-installed-p package)
      (package-install package))
    (require package))
#+END_SRC

* Personal Information

My name and email address helps Emacs format various messages.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Pavel Panchekha")
  (setq user-mail-address "me@pavpanchekha.com")
#+END_SRC

I keep my custom-set variables separate from my true configuration file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+END_SRC

* Graphical Interface Quirks

I now use the =better-defaults= package to turn off the scroll bar, tool
bar, and menu bar. It also turns off beeps and TABs.

Instead of the menu bar, I put the mode line at the top of the document (a trick I took from [[http://bzg.fr/emacs-strip-tease.html][Bastien Guerry]]):

#+BEGIN_SRC emacs-lisp
  (setq-default header-line-format mode-line-format)
  (setq-default mode-line-format nil)
#+END_SRC

Instead of the startup screen (I launch from the daemon anyway), I
prefer Emacs open my home directory, where I link current projects.

#+BEGIN_SRC emacs-lisp
  (setq initial-buffer-choice "~/")
#+END_SRC

Backups should go in the Emacs hidden directory, plus some more options [[https://stackoverflow.com/questions/151945/how-do-i-control-how-emacs-makes-backup-files][from SO]]:

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `(("." . "~/.emacs.d/backups/"))
        delete-old-versions t
        backup-by-copying t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)
#+END_SRC

The mode-line is made more useful by showing the column number and
progress through the file. The column number is especially handy for
avoiding long lines and for debugging error messages.

#+BEGIN_SRC emacs-lisp
  (setq column-number-mode t)
  (setq size-indication-mode t)
#+END_SRC

I rarely use the mouse, so tooltips are an annoyance. They appear in the echo area instead.

#+BEGIN_SRC emacs-lisp
  (tooltip-mode -1)
#+END_SRC

For scrolling, I ask Emacs to scroll at most five lines at a time and to keep 5 lines between the cursor and the top/bottom of the page. This helps me keep my place in the document.

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 5)
(setq scroll-margin 5)
#+END_SRC

I use a [[https://github.com/cathywu/TimeTracker][time tracker]] that records window titles.  This is more handy if I display the currently file path in the window title.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '(:eval (if (buffer-file-name)
                    (concat "Emacs: " (abbreviate-file-name (buffer-file-name)))
                  "Emacs: %b")))
#+END_SRC

When I teach or project it's good to have light mode, but I prefer to code in dark mode.

#+BEGIN_SRC emacs-lisp
  (defun toggle-tango-themes ()
    "Toggle between `tango` and `tango-dark` themes."
    (interactive)
    (let ((light 'tango)
          (dark 'tango-dark))
      (cond
       ((member light custom-enabled-themes)
        (disable-theme light)
        (load-theme dark t))
       ((member dark custom-enabled-themes)
        (disable-theme dark)
        (load-theme light t))
       (t
        ;; If neither is active, default to tango
        (load-theme light t)))))
#+END_SRC

I also like =triple-split= to split the screen into three vertical
columns, which I find handy because all three columns end up about 80
characters wide

#+BEGIN_SRC emacs-lisp
  (defun triple-split ()
    (interactive)
    (delete-other-windows)
    (split-window-right)
    (split-window-right)
    (balance-windows))
#+END_SRC

* Evil: key commands à la Vim

[[http://gitorious.org/evil/pages/Home][Evil]] is the Vim key-stroke language for Emacs. I also use =evil-leader= to get extra shortcuts.

#+BEGIN_SRC emacs-lisp
  (global-evil-leader-mode)
  (evil-leader/set-leader "SPC")
  (evil-mode 1)
#+END_SRC

Visual line mode is what Emacs calls “word wrap”. I use it in all text modes, so I ask Evil to execute commands on visual lines; otherwise these commands all need to be prefixed with =g=. The commands =I= and =A= should act similarly, but they do not yet have associated =-visual-line= versions.

#+BEGIN_SRC emacs-lisp
(define-key evil-motion-state-map "j" #'evil-next-visual-line)
(define-key evil-motion-state-map "k" #'evil-previous-visual-line)
(define-key evil-motion-state-map "$" #'evil-end-of-visual-line)
(define-key evil-motion-state-map "^" #'evil-first-non-blank-of-visual-line)
(define-key evil-motion-state-map "0" #'evil-beginning-of-visual-line)
#+END_SRC

Evil binds =RET=, which is often used in other modes. This unbinds it:

#+BEGIN_SRC emacs-lisp
(define-key evil-motion-state-map (kbd "RET") nil)
#+END_SRC

I have a few shortcuts using the =SPC= leader. I usually stick tools I develop into here;

#+NAME: evil-leader-bindings
| Key | Function                 |
|-----+--------------------------|
| SPC | counsel-M-x              |
| a   | amp-magit-start-thread   |
| b   | ivy-switch-buffer        |
| c   | org-capture              |
| d   | toggle-debug-on-error    |
| e   | eshell                   |
| f   | counsel-find-file        |
| g   | ripgrep-regexp           |
| h   | help-for-help            |
| j   | my-open-journal          |
| l   | my/latexmk-start         |
| m   | magit-status             |
| r   | revert-buffer            |
| s   | save-buffer              |
| t   | toggle-tango-themes      |
| v   | start-python-http-server |
| TAB | mode-line-other-buffer   |
| 3   | triple-split             |

#+BEGIN_SRC emacs-lisp :var bindings=evil-leader-bindings
  (dolist (row (cdr bindings))
    (evil-leader/set-key (car row) (intern (cadr row))))
#+END_SRC

* Ivy / Counsel

Ivy is an incredible search interface. I used to use Helm, but it was too slow, and it seems that Ivy is getting popular.

#+BEGIN_SRC emacs-lisp
  (ivy-mode 1)
  (counsel-mode 1)
#+END_SRC

Some additional information in Ivy:

#+BEGIN_SRC emacs-lisp
  (setq ivy-use-virtual-buffers t)
  (setq ivy-height 10)
#+END_SRC

* Git integration (Magit)

[[http://magit.github.io/magit/][Magit]] is an incredible Emacs interface to the [[https://git-scm.com][Git version-control
system]]. I have a Magit binding in my leader map. Magit uses =SPC= for
=magit-show-item-or-scroll-up=, which I don’t use. I bind it to use my
leader key instead.

#+BEGIN_SRC emacs-lisp
  (define-key magit-mode-map (kbd "SPC") nil)
  (add-hook 'magit-mode-hook #'evil-leader-mode)
#+END_SRC

* Writing
** Blogging

I maintain a [[https://pavpanchekha.com][blog]], and the blog is stored in =~/www/=, which is maintained by =git=. To make it easier to keep track of draft posts I've written but not published, I wrote a Magit section that shows up right after "Untracked Files":

#+BEGIN_SRC emacs-lisp
  (defvar my-blog-directory (expand-file-name "~/www/"))

  (defun my-magit-insert-blog-posts ()
    "Insert section detailing my unpublished blog posts"
    (when (equal default-directory my-blog-directory)
      (let ((unpublished-posts (split-string (shell-command-to-string "bash etc/drafts.sh") "\n" t)))
        (when unpublished-posts
          (magit-insert-section (blog-posts)
            (magit-insert-heading "Unpublished blog posts:")
            (dolist (post unpublished-posts)
              (magit-insert-section (file (concat "blog/" post))
                (insert (propertize (concat "blog/" post) 'face 'magit-filename) ?\n)))
            (insert ?\n))))))
#+END_SRC

The referenced =drafts.sh= file looks for all blog posts not named on
the home page and outputs them in a list. I want this section to show
up only in the blog post directory, so I check the directory and add a
hook buffer-locally.

#+BEGIN_SRC emacs-lisp
  (defun my-magit-setup-blog-posts ()
    (when (equal default-directory my-blog-directory)
      (magit-add-section-hook 'magit-status-sections-hook 'my-magit-insert-blog-posts
                              'magit-insert-untracked-files 'after t)))

  (add-hook 'magit-mode-hook 'my-magit-setup-blog-posts)
#+END_SRC

** Editing text

=visual-line-mode= implements proper line wrapping, which I prefer. For Org mode I also turn on proportional fonts. But traditionally Markdown files are hard-wrapped, and use ASCII fixed-text conventions more. LaTeX files get the same treatment; they also turn off automatic indentation, to help me with my peculiar LaTeX style where lines are broken at each phrase and all phrases except the first in a sentence are indented.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'visual-line-mode)
  (add-hook 'org-mode-hook 'variable-pitch-mode)
  (add-hook 'org-mode-hook 'org-toggle-pretty-entities)

  (add-hook 'markdown-mode-hook 'auto-fill-mode)

  (add-hook 'latex-mode-hook 'auto-fill-mode)
  (add-hook 'latex-mode-hook 'variable-pitch-mode)
  (add-hook 'latex-mode-hook (lambda () (electric-indent-mode -1)))
#+END_SRC

I’ve gone back and forth on single- and double-spaced sentences, but for now I’m in the single-spacing camp.

#+BEGIN_SRC emacs-lisp
  (setf sentence-end-double-space nil)
#+END_SRC

I usually like to build LaTeX with =latexmk=, and this command starts =latexmk= in preview mode in the current directory---very handy.

#+BEGIN_SRC emacs-lisp
    ;; -*- lexical-binding: t; -*-
    (require 'seq)

    (defvar my/latexmk-buffer "*latexmk*"
      "Buffer name for the latexmk -pvc process.")

    (defun my/latexmk--choose-target ()
      "Pick main .tex target: prefer main.tex or paper.tex in current dir, else prompt."
      (let* ((dir (or (and (buffer-file-name)
                           (file-name-directory (buffer-file-name)))
                      default-directory))
             (candidates (list (expand-file-name "main.tex" dir)
                               (expand-file-name "paper.tex" dir)
                               (expand-file-name "letter.tex" dir)))
             (target (seq-find #'file-exists-p candidates)))
        (unless target
          (setq target
                (read-file-name "Main TeX file: " dir nil t nil
                                (lambda (f) (string-match-p "\\.tex\\'" f)))))
        (expand-file-name target)))

    (defun my/latexmk-running-p ()
      "Is our latexmk watcher currently running?"
      (let ((proc (get-buffer-process my/latexmk-buffer)))
        (and proc (process-live-p proc))))

    (defun my/latexmk-stop ()
      "Stop the running latexmk watcher (if any) and kill its buffer."
      (interactive)
      (when (my/latexmk-running-p)
        (let ((proc (get-buffer-process my/latexmk-buffer)))
          (interrupt-process proc)
          (sit-for 0.1)
          (ignore-errors (kill-process proc))))
      (when (get-buffer my/latexmk-buffer)
        (kill-buffer my/latexmk-buffer))
      (message "latexmk watcher stopped."))

    (defun my/latexmk-start (&optional restart)
      "Start latexmk with -pdf -pvc -interaction=nonstopmode.
    With prefix arg RESTART (C-u), force-restart even if already running.
    If a watcher is running, this will restart it so the PDF viewer reopens."
      (interactive "P")
      (let* ((target (my/latexmk--choose-target))
             ;; latexmk prefers being run from the file's directory
             (default-directory (file-name-directory target))
             (args (list "latexmk" "-pdf" "-pvc" "-shell-escape" "-interaction=nonstopmode" target)))
        (when (or restart (my/latexmk-running-p))
          (my/latexmk-stop))
        (apply #'start-process "latexmk" (get-buffer-create my/latexmk-buffer) args)
        ;; Use compilation-mode for clickable errors, etc.
        (with-current-buffer my/latexmk-buffer
          (compilation-mode))
        (message "latexmk watching %s" (file-name-nondirectory target))))

    (defun my/latexmk-restart ()
      "Restart the latexmk watcher (or start it if not running)."
      (interactive)
      (my/latexmk-start 'restart))
#+END_SRC

** Spell checking

In the text modes I use, I turn on spell checking.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'flyspell-mode)
  (add-hook 'markdown-mode-hook 'flyspell-mode)
  (add-hook 'latex-mode-hook 'flyspell-mode)
#+END_SRC

Fly-spell mode uses ISpell. I want to use the =ispell= program, to use American English, and to locate my personal dictionary within my =.emacs.d= directory.

#+BEGIN_SRC emacs-lisp
(setf ispell-program-name "/opt/homebrew/bin/aspell")
(setf ispell-personal-dictionary "~/.emacs.d/dict")
#+END_SRC

A key binding I really miss from Vim is the spell checking keys =zg= and
=z==. Emacs has a great spell-check built-in: Ispell. All we need to do
is add a few key-bindings, though annoyingly =ispell-save-word= is not
built in.

#+BEGIN_SRC emacs-lisp
  (defun ispell-save-word ()
    (interactive)
    (ispell-send-string (concat "*" (car (ispell-get-word nil)) "\n"))
    (ispell-pdict-save t nil))
#+END_SRC

Finally, we add key-bindings using Evil's =evil-normal-state-map=.

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map "z=" 'ispell-word)
(define-key evil-normal-state-map "zg" 'ispell-save-word)
(define-key evil-normal-state-map "zn" 'flyspell-goto-next-error)
#+END_SRC

** Org-mode

I give Org-mode files a =txt= extension because this allows editing them on other devices.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
#+END_SRC

Org-mode indents description lists so as to keep a consistent left edge. I don't like this behavior.

#+BEGIN_SRC emacs-lisp
  (setf org-description-max-indent 0)
#+END_SRC

I prefer to hide the inline markup used by Org-mode.

#+BEGIN_SRC emacs-lisp
  (setf org-hide-emphasis-markers t)
  (setf org-hide-leading-stars t)
#+END_SRC

** Notes and journal

I keep a journal for random notes (not for journaling)

#+BEGIN_SRC emacs-lisp
  (defun my-open-journal ()
    (interactive)
    (find-file "~/Dropbox/journal.org"))
#+END_SRC

I've got a few capture templates:

#+BEGIN_SRC emacs-lisp
  (setf org-capture-templates
        '(("j" "Journal Entry" entry (file "~/Dropbox/journal.org")
           "* %? %T" :prepend t)))

  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

* Programming Language and File Format Tweaks
** Log files

Log files and SMT-LIB files often have long lines (SMT-LIB because it's usually computer-generated), and Emacs doesn't deal particularly well with those, so I turn on truncate-long-lines mode for those files.

#+BEGIN_SRC emacs-lisp
(defun log-truncate-long-lines ()
  (when (and (stringp buffer-file-name) (string-match-p "\\.\\(smt2\\|log\\)$" buffer-file-name))
    (toggle-truncate-lines)))
(add-hook 'find-file-hook 'log-truncate-long-lines)
#+END_SRC

** FPCore

FPCore is the vaguely Scheme-derived format behind [[http://fpbench.org][FPBench]].

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.fpcore" . scheme-mode))
#+END_SRC

** Racket

I usually use the Racket dialect of Scheme, but I've used MIT-Scheme heavily in undergrad. For a while I used the [[http://www.neilvandyke.org/quack/][Quack]] and [[http://www.nongnu.org/geiser/][Geiser]] packages, which sort of supported multiple implementations, but now I use the =racket-mode= package, which has much deeper support for Racket but does not attempt to support other dialects at all. Which I think is OK, the other dialects are not used much.

It is customary in Racket to use a proper Unicode λ instead of the symbol =lambda=. I hack the abbreviation tools in Emacs to make this happen: I set =lambda= to be an abbreviation for =λ=.

#+BEGIN_SRC emacs-lisp
   (require 'abbrev)
   (add-hook 'scheme-mode-hook
     (lambda ()
       (abbrev-mode 1)
       (define-abbrev scheme-mode-abbrev-table "lambda" "λ")))
#+END_SRC

Perfectly matching parentheses is annoying; =electric-pair-mode= automatically inserts closing parentheses when I type the open parenthesis. This works great with =show-paren-mode=, which automatically highlights the matching parenthesis (=show-paren-mode= is provided by =better-defaults=).

#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook 'electric-pair-mode)
#+END_SRC

** Directories (dired)

Dired is great for exploring a file system and so on.

#+BEGIN_SRC emacs-lisp
  (require 'dired-x)
  (setf dired-omit-files "^\\.?#\\|^\\.")
#+END_SRC

Because Emacs shows the =~= directory when I open it up,
  I prefer this directory specifically not to show hidden files.

#+BEGIN_SRC emacs-lisp
  (defun dired-hide-details-home ()
    "Hide details and hidden files,
     if the current buffer is the home directory."
    (when (equal (expand-file-name default-directory) (expand-file-name "~/"))
      (dired-hide-details-mode)
      (dired-omit-mode)))

  (add-hook 'dired-mode-hook 'dired-hide-details-home)
#+END_SRC

** PDFs (doc-view)

I sometimes use doc-view for long PDFs (though rarely now).

For long PDFs, continuous scrolling is best.

#+BEGIN_SRC emacs-lisp
  (setf doc-view-continuous t)
#+END_SRC

144 is a decent resolution, since it makes a page of text about as wide as half my screen, and I generally use Emacs with two vertical panes.

#+BEGIN_SRC emacs-lisp
  (setf doc-view-resolution 144)
#+END_SRC

Doc-view works much better with Vim-style h/j/k/l movement keys.

#+BEGIN_SRC emacs-lisp
  (require 'doc-view)
  (define-key doc-view-mode-map (kbd "j") 'doc-view-next-line-or-next-page)
  (define-key doc-view-mode-map (kbd "k") 'doc-view-previous-line-or-previous-page)
  (define-key doc-view-mode-map (kbd "h") 'image-backward-hscroll)
  (define-key doc-view-mode-map (kbd "l") 'image-forward-hscroll)
#+END_SRC

** Emacs Lisp programming tools

I'm also often shaving my Emacs configuration (this file). It's
helpful to jump to it and reload it quickly.,

#+BEGIN_SRC emacs-lisp
(defun reconfigure () (interactive)
  (load-file "~/.emacs.d/init.el"))

(defun edconfigure () (interactive)
  (find-file "~/.emacs.d/emacs.org"))
#+END_SRC

* Inter-Key Timings

One interesting characteristic of a person's typing is their inter-key timings -- the time between typing two letters in succession.  For example, it usually takes more time to type "cr" than ";l", since one involves moving the left index finger a large distance and the other uses the really natural rolling chord on the right hand.  By recording all key character pairs, we can actually track timings for this.  And since I do a lot of my work in Emacs, it is easiest to do this as an Emacs extension.

I've written such a thing: [[http://git.pavpanchekha.com/?p=keylogger.el.git;a=summary][keylogger.el]].  It has an Emacs Lisp extension and an analyzer written in Javascript.  I turn it on when Emacs starts:

#+BEGIN_SRC emacs-lisp
  (load "~/Dropbox/Archive/keylogger.el/keylogger.el")
  (setf keylogger-filename (concat "~/Dropbox/Data/keys." (system-name) ".el"))
  (keylogger-load)
  (keylogger-start)
  (keylogger-autosave)
#+END_SRC

Note that each startup, I load the file, load my previously-saved data, tell it to record new key presses, and to autosave them every fifteen minutes.

* Emacs Shell

I use =eshell= as my shell, and set up =eat= to handle commands that need visual mode:

#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-load-hook #'eat-eshell-visual-command-mode)
#+END_SRC

Here's something ChatGPT wrote to help with long-running eshell commands. If a command ends and Emacs isn't foregrounded (because it's a long command and I tabbed away) it raises a macOS notification. It needs the =terminal-notifier= Homebrew package installed, otherwise there is some annoying permissions thing I couldn't get working.

#+BEGIN_SRC emacs-lisp
  (defun pavel/format-eshell-command ()
    "Reconstruct the full eshell command as a string."
    (string-join
     (cons eshell-last-command-name
           (mapcar #'eshell-escape-arg eshell-last-arguments))
     " "))

  (defun pavel/eshell-maybe-notify ()
    (unless (frame-focus-state)
      (start-process "notify" nil "terminal-notifier"
                     "-title" (if (= eshell-last-command-status 0)
                                  "✅ Emacs Command Done"
                                "❌ Emacs Command Failed")
                     "-message" (pavel/format-eshell-command)
                     "-activate" "org.gnu.Emacs")))

  (add-hook 'eshell-post-command-hook #'pavel/eshell-maybe-notify)
#+END_SRC

* Web Server

I often want to start a basic web server to serve some local files. Browsers have locked down =file://= a lot (maybe too much?) and a lot of basic JS patterns don't work with local files any more.

Here are some nice keybindings (that ChatGPT wrote for me) to start the Python web server pointed to a local directory. 

#+BEGIN_SRC emacs-lisp
  (defvar web-server--process nil
    "The current Python HTTP server process.")

  (defvar web-server--mode-line-string ""
    "String to display in the mode line when web server is running.")
  (put 'web-server--mode-line-string 'risky-local-variable t)
  (add-to-list 'global-mode-string 'web-server--mode-line-string t)

  (defconst web-server--buffer-name "*web-server*")

  (defconst web-server--port 8000)
#+END_SRC

You start it with space-V (for server).

#+BEGIN_SRC emacs-lisp
  (defun stop-python-http-server ()
    "Stop the current web server"
    (interactive)
    (when (and web-server--process (process-live-p web-server--process))
      (pop-to-buffer web-server--buffer-name)
      (unless (yes-or-no-p "A web server is running—kill it? ")
        (user-error "Aborted starting new server"))
      (kill-process web-server--process)
      (setq web-server--process nil)
      (setq web-server--mode-line-string "")
      (force-mode-line-update t)
      (message "Previous web server killed.")))

  (defun start-python-http-server ()
    "Prompt for a directory and launch `python3 -m http.server -d DIR` in *web-server*.
  If a server is already running, switch to its buffer so you can inspect the log,
  prompt to kill it, then start a new one. Finally restore the buffer you were in,
  even if you abort."
    (interactive)
    (let* ((dir         (read-directory-name "Directory for HTTP server: ")))
      ;; If already running, show its log and ask to kill
      (save-window-excursion
        (stop-python-http-server))
      ;; Start new server
      (let ((default-directory dir))
        (setq web-server--process
              (start-process "web-server" web-server--buffer-name
                             "python3" "-m" "http.server" "-d" dir
                             (number-to-string web-server--port))))
      (setq web-server--mode-line-string
            (format " [HTTP:%s %s]" web-server--port
                    (abbreviate-file-name dir)))
      (force-mode-line-update t))
    ;; Prep log buffer
    (with-current-buffer web-server--buffer-name
      (read-only-mode 1)
      (goto-char (point-max))))
#+END_SRC

* Amp integration

#+BEGIN_SRC emacs-lisp
  (require 'magit)
  (require 'subr-x)

  (defun amp--git (repo &rest args)
    "Run git ARGS in REPO, returning (exit-code . output-string)."
    (let* ((default-directory repo)
           (buf (generate-new-buffer " *amp-git*"))
           (status (apply #'process-file "git" nil buf nil args))
           (out (with-current-buffer buf (buffer-string))))
      (kill-buffer buf)
      (if (zerop status)
          (string-trim out)
        (error "git %s failed: %s" (string-join args " ") out))))

  (defun amp--ensure-line-in-file (file line)
    "Append LINE to FILE if not already present (match per line)."
    (let ((existing (when (file-exists-p file)
                      (with-temp-buffer
                        (insert-file-contents file)
                        (buffer-string)))))
      ;; Use multiline regexp so ^/$ are per-line
      (unless (and existing
                   (string-match-p (concat "^" (regexp-quote line) "$") existing))
        (make-directory (file-name-directory file) t)
        (with-temp-buffer
          (when existing
            (insert existing)
            (unless (or (string-empty-p existing)
                        (string-suffix-p "\n" existing))
              (insert "\n")))
          (insert line "\n")
          (write-region (point-min) (point-max) file nil 'silent)))))

  (defun amp--parse-thread-id (s)
    "Heuristically extract a thread id from S."
    (let* ((lines (split-string (string-trim s) "\n" t "[ \t\r]+"))
           ;; Try exact single-line first
           (one (and (= (length lines) 1) (car lines))))
      (cond
       ((and one (> (length one) 0)) one)
       ;; Else: look for something id-like in the last line
       (t
        (save-match-data
          (let ((last (car (last lines))))
            (if (and last (string-match "\\([A-Za-z0-9_-]+\\)\\s-*\\'" last))
                (match-string 1 last)
              (error "Could not parse thread id from: %S" s))))))))

  (defun amp--base-for-new-branch (branches)
    "Choose a reasonable base for a new branch.
  Prefer local main/master; else origin/main|master; else current branch."
    (or (and (member "main" branches) "main")
        (and (member "master" branches) "master")
        (and (magit-rev-verify "origin/main") "origin/main")
        (and (magit-rev-verify "origin/master") "origin/master")
        (magit-get-current-branch)
        (user-error "Cannot find a suitable base branch (tried main/master)")))

  (defun amp--get-amp-thread (file)
    "Get the amp thread ID cached in the file, if it exists, or create one"
    (if (file-exists-p thread-file)
        (string-trim (with-temp-buffer
                       (insert-file-contents thread-file)
                       (buffer-string)))
      (let* ((tid (with-temp-buffer
                    (if (zerop (call-process "amp" nil t nil "threads" "new"))
                        (amp--parse-thread-id (buffer-string))
                      (error "Running `amp threads new` failed:\n%s" (buffer-string))))))
        (with-temp-file thread-file
          (insert tid "\n"))
        tid)))

  ;;;###autoload
  (defun amp-magit-start-thread ()
    "Create/continue an AMP thread tied to a Git branch.

      Steps:
      - Find repo from current buffer (Magit).
      - Ensure .worktrees exists
      - Add to .gitignore if missing.
      - Prompt for branch (completes from local branches; new names allowed).
      - Ensure .worktrees/<branch> dir exists; create branch if missing (from main/master/origin/main).
      - Use/obtain .worktrees/<branch>.ampthread for thread id.
      - Open buffer *amp:<branch>* running: amp thread continue <threadid>."
    (interactive)
    (unless (require 'vterm nil t)
      (user-error "vterm is required to run amp; install it with M-x package-install RET vterm RET"))

    ;; 1) Find repo root
    (let* ((repo (or (magit-toplevel) (user-error "Not inside a Git repository"))))
      (let* ((wt-root (expand-file-name ".worktrees" repo))
             (gitignore (expand-file-name ".gitignore" repo)))
        ;; 2) Create worktree directory
        (make-directory wt-root t)
        ;; 3) Ensure .worktrees in .gitignore
        (amp--ensure-line-in-file gitignore ".worktrees")
        ;; 4) Prompt for branch with completion
        (let* ((branches (magit-list-local-branch-names))
               (prompt   "Branch (existing or new): ")
               (branch (completing-read prompt branches nil nil nil nil
                                        (magit-get-current-branch)))
               (branch-exists (member branch branches))
               (base (amp--base-for-new-branch branches)))
          ;; 5) Ensure .worktrees/<branch> dir exists
          (let* ((wt-dir (expand-file-name branch wt-root)))
            (if branch-exists
                (if (file-exists-p wt-dir)
                    (message "Branch %s and its worktree exists" branch)
                    (amp--git repo "worktree" "add" wt-dir branch))
              (amp--git repo "worktree" "add" "-b" branch wt-dir base))
            ;; 6) Get or create AMP thread id
            (let* ((thread-file (expand-file-name (format "%s.ampthread" branch) wt-root))
                   (default-directory wt-dir)
                   (thread-id (amp--get-amp-thread thread-file))
                   ;; 7) Open terminal buffer and run amp continue
                   (bufname (format "*amp:%s*" branch)))
              (message "Thread ID %s" thread-id)
              ;; Create or reuse buffer
              (when (get-buffer bufname)
                (kill-buffer bufname))
              ;; Launch AMP in the worktree, then split: [ Magit | AMP ]
              (let* ((amp-buf (get-buffer-create bufname)))
                ;; Start AMP in vterm without popping the buffer yet
                (with-current-buffer amp-buf
                  (evil-local-mode -1)
                  (vterm-mode)
                  (vterm-send-string (format "exec amp thread continue %s" thread-id))
                  (vterm-send-return))
                
                ;; Two-column layout: left = Magit, right = AMP
                (delete-other-windows)
                (let* ((left  (selected-window))
                       (right (split-window-right)))
                  ;; Left: Magit for the worktree
                  (select-window left)
                  (let* ((magit-buf (magit-status wt-dir)))
                    (with-current-buffer magit-buf
                      (magit-auto-revert-mode 1))
                    (set-window-buffer left magit-buf))

                  ;; Right: the AMP terminal buffer (and leave focus here)
                  (select-window right)
                  (set-window-buffer right amp-buf)
                  (balance-windows))))
            (message "AMP thread ready for branch %s" branch))))))
#+END_SRC

The annoying thing about this is that vterm is kinda slow. ChatGPT said this would help:

#+BEGIN_SRC emacs-lisp
(setq fast-but-imprecise-scrolling t
      redisplay-skip-fontification-on-input t
      inhibit-compacting-font-caches t)  ;; macOS CoreText can be slow
#+END_SRC

And maybe also this, also a ChatGPT suggestion:

#+BEGIN_SRC emacs-lisp
;; Bigger pipe for subprocess output (Emacs 27+)
(setq read-process-output-max (* 1024 1024))  ; 1MiB

;; vterm tuning
(setq vterm-timer-delay 0.01)          ;; lower = more frequent updates (default is OK; try 0.01–0.02)
(setq vterm-max-scrollback 1000)       ;; don’t keep huge scrollback
(setq vterm-kill-buffer-on-exit t)

;; Buffer-local UI trims for vterm
(add-hook 'vterm-mode-hook
          (lambda ()
            (setq-local global-hl-line-mode nil)
            (setq-local display-line-numbers nil)
            (setq-local cursor-in-non-selected-windows nil)))
#+END_SRC
