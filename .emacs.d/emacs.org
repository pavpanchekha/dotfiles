#+TITLE: Emacs Initialization Script

All of my Emacs initialization is contained within this one Literate
Babel file.  I use the Babel system in Org-mode to evaluate the code
within on Emacs startup, which lets me write nice descriptive text for
my code.  My =.emacs.d/init.el= file contains only:

: (require 'org-install)
: (require 'ob-tangle)
: (mapc #'org-babel-load-file (directory-files "~/.emacs.d/" t "\\.org$"))

More on this method can be found [[http://orgmode.org/worg/org-contrib/babel/intro.html#sec-8_2][in the Babel tutorial]].

* Miscellany
** Startup

Emacs might as well know my name and email address.  I trust it.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Pavel Panchekha")
(setq user-mail-address "me@pavpanchekha.com")
#+END_SRC

To make sure that Emacs can load some extra libraries that I've set
up, I need to add my local =load-path= to the list.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/load-path")
#+END_SRC

Also, I like to keep my custom-set variables from polluting my other
files, so I like to move the =custom-file=.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

Finally, since I publish this file on the Internet, I don't want
passwords in it.  So I keep them elsewhere, and load them here:

#+BEGIN_SRC emacs-lisp
(org-babel-load-file "~/.emacs.d/passwords.org")
#+END_SRC

** GUI Settings

Some things Emacs does by default just use up screen real estate and
programmer patience.  Note that =tool-bar-mode= requires a *nonzero*
parameter, not a truthy parameter, to display the toolbar.  This is
absolutely absurd, but what can one do?

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message t)
(set-scroll-bar-mode nil)
(tool-bar-mode 0)
#+END_SRC

I'm not yet pro enough to forsake =menu-bar-mode=, though one day I'll
get there.

Also, I like knowing where my files end; ergo I ask Emacs to show
empty lines.

#+BEGIN_SRC emacs-lisp
(if (not indicate-empty-lines)
  (toggle-indicate-empty-lines))
#+END_SRC

Also, a color theme.  Yes, it's really called "whateveryouwant".

#+BEGIN_SRC emacs-lisp
(require 'color-theme)
(color-theme-initialize)
(color-theme-whateveryouwant)
#+END_SRC

The modeline should really be pressed into useful service.  I make it
display the time, and for the position display, have it give the column
number and file size:

#+BEGIN_SRC emacs-lisp
(display-time-mode t)
(setq column-number-mode t)
(setq size-indication-mode t)
#+END_SRC

The =yes or no= prompts get annoying quickly.  Instead, we ask Emacs to
use single-character responses

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Since I rarely use the mouse, tooltips are more an annoyance than
anything else.  This switches them to appear in the echo area.

#+BEGIN_SRC emacs-lisp
(tooltip-mode -1)
(setq tooltip-use-echo-area t)
#+END_SRC

** Basic File Behaviors

Emacs has some stupid defaults, such as making those =file~= files and
using tabs for indentation.  I also make Emacs add final newlines and
to prompt me for only single characters (why is that default?).

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq-default indent-tabs-mode nil)
(setq require-final-newline t)
#+END_SRC

Also, I often have multiple buffers open with the same name.  Emacs
usually deals with this by appending the buffer number to the buffer
name.  This is hard to keep track of.  Instead, the =uniquify= library
uses the parent directory name, which I usually know.

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'post-forward-angle-brackets)
#+END_SRC
   
** Games

It's very important that score files are placed correctly (can't lose
my tetris high scores!):

#+BEGIN_SRC emacs-lisp
(setq tetris-score-file "~/.emacs.d/scores/tetris")
(setq snake-score-file  "~/.emacs.d/scores/snake")
#+END_SRC

* Key Bindings
** Vim Key Bindings

We use the [[http://gitorious.org/evil/pages/Home][Evil package]] for Vim keybindings in Emacs.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/evil")
  (require 'evil)
  (evil-mode 1)
#+END_SRC

** Ispell =ispell-insert-word=

Another key binding I really miss from Vim is the spelling key
bindings =zg= and =z==; these make spell-checking much nicer to use.
Emacs has a great spell-check built-in: Ispell.  All we need to do is
add a few key-bindings.  But first we need a function to bind to, and
for =zg=, one does not exist.  So off we go to implement
=ispell-insert-word= (insert being what Ispell calls adding a word to
your dictionary).

#+BEGIN_SRC emacs-lisp
(defun ispell-insert-word ()
  (interactive)
#+END_SRC

First, we need to *get* the current word.  We don't need to explicitly
use =ispell-following-word=, since =ispell-get-word= does this for us.
=ispell-get-word= returns a list of =word=, =start=, =end= (though its
documentation certainly doesn't hint at such), so we call =car= to
extract the word itself.

#+BEGIN_SRC emacs-lisp
  (let ((word (car (ispell-get-word nil))))
#+END_SRC

Now we can call =ispell-send-string=.  Its documentation is pretty
weak (and that's if I want to be nice), but from reading the code of
=ispell-command-loop= (search for =?i=), it seems like we want to send
=*word\n=, where =word= is the word in question.

#+BEGIN_SRC emacs-lisp
  (ispell-send-string (concat "*" word "\n"))
#+END_SRC

Finally, since we modified the dictionary, we want to save it.  To be
nice, we're going to first mark the dictionary as modified.  We only
want to force a save, though, if the dictionary was clean before-hand,
so we save the old value.

#+BEGIN_SRC emacs-lisp
  (let ((old-ispell-pdict-modified-p ispell-pdict-modified-p))
    (setq ispell-pdict-modified-p '(t))
#+END_SRC

And finally, we want force a save if necessary.  The "if necessary"
part is actually annoyingly complicated...

#+BEGIN_SRC emacs-lisp
    (when (or (and old-ispell-pdict-modified-p
                   (listp old-ispell-pdict-modified-p)
                   (car ispell-pdict-modified-p))
              (and ispell-pdict-modified-p
                   (not (listp ispell-pdict-modified-p)))))
#+END_SRC

But once that's out of the way, we can just call =ispell-pdict-save=
with =no-query=.

#+BEGIN_SRC emacs-lisp
      (ispell-pdict-save t))))
#+END_SRC

Finally, we add key-bindings using Evil's =evil-normal-state-map.

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map "z=" 'ispell-word)
(define-key evil-normal-state-map "zg" 'ispell-insert-word)
#+END_SRC

** Miscellaneous

I prefer to work with indented text at all times, so =RET= should be
bound to =newline-and-indent=, and some terminals have problems with
the delete key or something, so I keep the following bindings around
as well.  The last line there make =C-k= kill the whole line.

#+BEGIN_SRC emacs-lisp
(global-set-key [C-m] 'newline-and-indent)
(global-set-key [delete] 'delete-char)
(setq kill-whole-line t)
#+END_SRC
** Searching and Scrolling

For searching, I enable highlighting as-I-search for both searches and
search/replaces.  Also, searches are made case-insensitive.  

#+BEGIN_SRC emacs-lisp
(setq search-highlight t)
(setq query-replace-highlight t)
(setq case-fold-search t)
#+END_SRC emacs-lisp

For scrolling, I ask Emacs to scroll at most five lines at a time and
to keep 5 lines between the cursor and the top/bottom of the page.

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 5)
(setq scroll-margin 5)
#+END_SRC

* Utility Commands
** =run= Command

I have a =run= command that I rather like; it compiles and runs some
program or file in a temporary program.  I use it for, for example,
compiling LaTeX, or testing C code.

#+BEGIN_SRC emacs-lisp
(defun run-command (file)
  (interactive (list (buffer-file-name)))
  (shell-command (concat "run " file " &")))

(defun compile-command (file)
  (interactive (list (buffer-file-name)))
  (shell-command (concat "run -c " file " &")))
#+END_SRC

Then we attach them to =[f5]= and =[C-f5]=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f5>") 'run-command)
(global-set-key (kbd "C-<f5>") 'compile-command)
#+END_SRC

** Printing to PDF

Sometimes, I need to print an Emacs buffer to PDF.  The standard
printing commands are less than ideal for this, since they rely on
=lpr=, a program I have no interest in installing and configuring.
Instead, I can use the Emacs =printing= package, which can export
buffers to Postscript, and then call =ps2pdf= to produce a PDF from
the Postscript.

First, I =require= in the =printing= package and ask it to install
itself into the Emacs menu tree.
  
#+BEGIN_SRC emacs-lisp
(require 'printing)
#+END_SRC

Now we write a function to print the current buffer.

#+BEGIN_SRC emacs-lisp
(defun print-to-pdf ()
  (interactive)
#+END_SRC

We want to use the function =pr-ps-buffer-pritn= from the =printing=
package.  We give it a temporary file to print to, and later we'll
=ps2pdf= that file.

#+BEGIN_SRC emacs-lisp
  (let* ((outfile (make-temp-file pr-ps-temp-file))
         (pdffile (concat outfile ".pdf")))
    (pr-ps-buffer-print 1 outfile)
    (shell-command (concat "ps2pdf "
                           (shell-quote-argument outfile)
                           " "
                           (shell-quote-argument pdffile)))
    (find-file pdffile)))
#+END_SRC

The default print settings are silly, especially once you consider
that my use case is print-to-PDF.  So I would rather print with syntax
highlighting and no headers.

#+BEGIN_SRC emacs-lisp
(setq pr-faces-p t
      ps-print-header nil
      ps-print-header-frame)
#+END_SRC

** Configuration editing configuration

I actually edit my Emacs configuration a lot.  I call it "cultivating"
my Emacs configuration.  So here are some utility functions for that.

The first function just reloads the Emacs configuration.

#+BEGIN_SRC emacs-lisp
(defun reconfigure ()
  (interactive)
  (load-file "~/.emacs.d/init.el"))
#+END_SRC

The second function opens the configuration up for editing.

#+BEGIN_SRC emacs-lisp
(defun edconfigure ()
  (interactive)
  (find-file "~/.emacs.d/emacs.org"))
#+END_SRC

* Slime

First, we tell Emacs where to find SLIME and load it.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/usr/share/emacs/site-lisp/slime")
(require 'slime)
#+END_SRC

Slime needs to be tols where to find my specific Swank loader (I
change what directory to dump FASLs in).  And, I set the Lisp to SBCL.

#+BEGIN_SRC emacs-lisp
(setq slime-backend "~/.emacs.d/slime/loader.lsp")
(setq inferior-lisp-program "/usr/bin/sbcl")
#+END_SRC

Now Slime can be set up.

#+BEGIN_SRC emacs-lisp
(slime-setup)
#+END_SRC

* Doc-View

I generally use doc-vew for long PDFs, so I find it best to have
continuous scrolling.

#+BEGIN_SRC emacs-lisp
(setq doc-view-continuous t)
#+END_SRC

Also, I often end up zooming a lot on PDFs, so I like rendering them
at high resolution.

#+BEGIN_SRC emacs-lisp
(setq doc-view-resolution 192)
#+END_SRC

The PDF viewer is in sore need of Vim-style h/j/k/l movement keys

#+BEGIN_SRC emacs-lisp
(require 'doc-view)
(define-key doc-view-mode-map (kbd "j") 'doc-view-next-line-or-next-page)
(define-key doc-view-mode-map (kbd "k") 'doc-view-previous-line-or-previous-page)
(define-key doc-view-mode-map (kbd "h") 'image-backward-hscroll)
(define-key doc-view-mode-map (kbd "l") 'image-forward-hscroll)
#+END_SRC

* Mode-specific Behaviors
** Text-like Modes

Since I like Org-mode so much, I feel it should be default for text
files.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
#+END_SRC

Other modes I use quite a bit are Restructured Text (for writing
Python code) and $\LaTeX$ (for class):

#+BEGIN_SRC emacs-lisp
(defun text-minor-modes ()
  (interactive)
  (auto-fill-mode 1)
  (flyspell-mode 1))

(add-hook 'text-mode-hook 'text-minor-modes)
(add-hook 'LaTeX-mode-hook 'text-minor-modes)
(add-hook 'org-mode-hook 'text-minor-modes)
#+END_SRC

Of course, if we're activating ISpell, we should set it up.  Firstly
we want to tell it to use =ispell=, to check spelling against American
English, and where my dictionary is.

#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "/usr/bin/ispell")
(setq ispell-dictionary "american")
(setq ispell-personal-dictionary "~/.emacs.d/dict")
#+END_SRC

** LaTeX

LaTeX requires a bit more setup, simply because *of course* I want
AucTeX.

#+BEGIN_SRC emacs-lisp
(load "auctex.el" nil t t)
(load "preview-latex.el" nil t t)
#+END_SRC

The default previews are a bit small for my tastes.

#+BEGIN_SRC emacs-lisp
(setq preview-scale-function 1.1)
#+END_SRC

** Language Modes

Some modes I just need to =(require)= in.  First, =load-path= need
setting up.

#+BEGIN_SRC emacs-lisp
(setq load-path
      (append load-path
              '("/usr/share/emacs/site-lisp/clojure-mode"
                "/usr/share/emacs/site-lisp/haskell-mode")))
#+END_SRC

Now we can require in Haskell, CoffeeScript, and Clojure modes.

#+BEGIN_SRC emacs-lisp
(require 'haskell-mode nil t)
(require 'clojure-mode nil t)
(require 'coffee-mode nil t)
#+END_SRC
* Org Mode

We first include Org mode, and tell it which modules to use.

#+BEGIN_SRC emacs-lisp
(require 'org-install)
#+END_SRC

First things first!  We should set up the file structure.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/notes/")
(setq org-agenda-files '("~/notes/"))
(setq org-default-notes-file (concat org-directory "pavel.org"))
#+END_SRC

Let's throw in a very minor editing thing (hitting =M-RET= shouldn't
split a bullet point in two).

#+BEGIN_SRC emacs-lisp
(setq org-M-RET-may-split-line '((default)))
#+END_SRC

** Agenda View

I use the agenda view a lot, so I customize it a bit.  The agenda
should show seven days (including, yes, the ones without events); it
shouldn't show me things I've done; and I won't worry about starting
on a weekend or weekday.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-ndays 7)
(setq org-agenda-show-all-dates t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-start-on-weekday nil)
#+END_SRC

** Todo Keywords

The keywords here represent a good chunk of possible work-flows.  TODO
to DONE is the standard one, but sometimes I go to WONT or spent time
cycling between TODO and WAIT.  SOMEDAY exists for the projects that
I'd like to do, but that are currently in limbo.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "SOMEDAY(s)" "|" "DONE(d)" "WAIT(w)" "WONT(n)")))
(setq org-use-fast-todo-selection t)
#+END_SRC

** Entities
Since I use things like \RR so often, I made them into entities, so that
Org can typeset them nicely.

#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t
        org-entities-user '(; Double-struck letters for various fields
                            ("CC" "\\CC" t "&#8450;" "C" "C" "ℂ")
                            ("FF" "\\FF" t "&#120125;" "F" "F" "𝔽")
                            ("HH" "\\HH" t "&#8461;" "H" "H" "ℍ")
                            ("NN" "\\NN" t "&#8469;" "N" "N" "ℕ")
                            ("PP" "\\PP" t "&#8473;" "P" "P" "ℙ")
                            ("QQ" "\\QQ" t "&#8474;" "Q" "Q" "ℚ")
                            ("RR" "\\RR" t "&#8477;" "R" "R" "ℝ")
                            ("ZZ" "\\ZZ" t "&#8484;" "Z" "Z" "ℤ")
  
                            ; Fraktur letters for ideals
                            ("ga" "\\ga" t "&#120094;" "a" "a" "𝔞")
                            ("gb" "\\gb" t "&#120095;" "b" "b" "𝔟")
                            ("gc" "\\gc" t "&#120096;" "c" "c" "𝔠")
                            ("gd" "\\gd" t "&#120097;" "d" "d" "𝔡")
                            ("gm" "\\gm" t "&#120106;" "m" "m" "𝔪")
                            ("gn" "\\gn" t "&#120107;" "n" "n" "𝔫")
                            ("go" "\\go" t "&#120108;" "o" "o" "𝔬")
                            ("gp" "\\gp" t "&#120109;" "p" "p" "𝔭")
                            ("gq" "\\gq" t "&#120110;" "q" "q" "𝔮")

                            ; Miscellaneous mathematical
                            ("setminus" "\\setminus" t "&#8726;" "\" "\" "∖")
                            ("mapsto"   "\\mapsto" t "&#8614;" "|->" "|->" "↦")
                            ))
#+END_SRC

I also would rather hide the stars and such that org-mode uses for
inline markup:

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

** Key bindings
Some key bindings are not bound by Org automatically, so I have to bind
them myself.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
#+END_SRC

** MobileOrg

I don't really use MobileOrg on my phone, since the Android MobileOrg
interface is somewhat unloved, but on principle I have it installed,
and so I need some setup here.

#+BEGIN_SRC emacs-lisp
(setq org-mobile-inbox-for-pull "~/notes/inbox.org")
(setq org-mobile-directory "~/Dropbox/Notes/mobile-org")
#+END_SRC

** LaTeX Export

Org-mode requires you to define things to use other classes for LaTeX files.

#+BEGIN_SRC emacs-lisp
  (setq org-export-latex-listings t)
  (setq org-export-latex-classes
        '(("simple"
           "\\documentclass{simple}
            [NO-DEFAULT-PACKAGES]
            [EXTRA]"
           ("\\section{%s}" . "\\section*{%s}")
           ("\\subsection{%s}" . "\\subsection*{%s}")
           ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
           ("\\paragraph{%s}" . "\\paragraph*{%s}")
           ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC

* Magit
  
Magit needs a =(require)= and an autoload.

#+BEGIN_SRC emacs-lisp
(require 'magit)
(autoload 'magit-status "magit" nil)
#+END_SRC

* W3M Browser

W3M is a nice web browser to use for tasks such as reading Hacker
News.  If it got a bit more love, it would be perfect...

#+BEGIN_SRC emacs-lisp
(require 'w3m)
#+END_SRC

First off, W3M should use UTF8 everywhere it can.

#+BEGIN_SRC emacs-lisp
(setq w3m-coding-system 'utf-8
      w3m-default-coding-system 'utf-8
      w3m-file-coding-system 'utf-8
      w3m-file-name-coding-system 'utf-8
      w3m-terminal-coding-system 'utf-8)
#+END_SRC

I change a few file locations.

#+BEGIN_SRC emacs-lisp
(setq w3m-default-save-directory "/tmp/")
(setq w3m-icon-directory "/tmp/")
#+END_SRC

W3M has some features that are, for whatever reason, off by default
(they're /experimental/; eh, work fine).

#+BEGIN_SRC emacs-lisp
(setq w3m-use-cookies t w3m-use-favicon t)
#+END_SRC

Finally I set up my homepage.

#+BEGIN_SRC emacs-lisp
(setq w3m-home-page "about:blank")
#+END_SRC

** Default Browsers

I prefer to set Firefox as Emacs's default browser, simply because
there are lots of sites W3M just doesn't work that well on.

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-firefox)
(setq browse-url-generic-program "google-chrome")
#+END_SRC

However, I still like the ability to throw open W3M easily.

#+BEGIN_SRC emacs-lisp
(autoload 'w3m-browse-url "w3m" "Ask a WWW browser to show a URL." t)
#+END_SRC

So I make a quick keybinding for browsing a URL.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-xm" 'browse-url-at-point)
(global-set-key "\C-xM" 'w3m-browse-url-at-point)
#+END_SRC

** Keybindings

=f= for "follow" is a very nice and intuitive keybinding for following
links.

#+BEGIN_SRC emacs-lisp
(define-key w3m-mode-map (kbd "f") 'w3m-view-this-url)
(define-key w3m-mode-map (kbd "F") 'w3m-view-this-url-new-session)
#+END_SRC

I prefer there to be a key to enter a new URL, blank-slate; and =o=
for "open" sounds like a good keybinding.

#+BEGIN_SRC emacs-lisp
(defun clean-slate-goto-url (url)
  (interactive (list (w3m-input-url nil "" nil nil 'feeling-lucky)))
  (w3m-goto-url url))

(define-key w3m-mode-map (kbd "o")   'clean-slate-goto-url)
(define-key w3m-mode-map (kbd "O")   'w3m-goto-url)
(define-key w3m-mode-map (kbd "C-o") 'w3m-view-previous-page)
#+END_SRC

The symmetric operations should clearly exist for tabs.

#+BEGIN_SRC emacs-lisp
(defun clean-slate-goto-url-new-session (url)
  (interactive (list (w3m-input-url nil "" nil nil 'feeling-lucky)))
  (w3m-goto-url-new-session url))

(define-key w3m-mode-map (kbd "t") 'clean-slate-goto-url-new-session)
(define-key w3m-mode-map (kbd "T") 'w3m-goto-url-new-session)
#+END_SRC

=d= for "delete" is pretty common.

#+BEGIN_SRC emacs-lisp
(define-key w3m-mode-map (kbd "d") 'w3m-delete-buffer)
#+END_SRC

Finally, I try to implement Vim-style tab switching.  This is a bit
more work...

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'vim-tab-switching)
(define-key w3m-mode-map (kbd "g") 'vim-tab-switching)

(define-key vim-tab-switching "t" 'w3m-next-buffer)
(define-key vim-tab-switching "T" 'w3m-previous-buffer)
#+END_SRC

Continuing on the Vim tradition, a good key for searching is =/=.

#+BEGIN_SRC emacs-lisp
(define-key w3m-mode-map "/" 'isearch-forward)
#+END_SRC

* Jabber

=jabber.el= is a great, great invention: it lets me view my Google
Chat in Emacs!  Require it, post-haste!

#+BEGIN_SRC emacs-lisp
(require 'jabber)
#+END_SRC

I also give =jabber.el= my account details.

#+BEGIN_SRC emacs-lisp
; Some variables
(setq jabber-account-list `(("pavpanchekha@gmail.com" 
                             (:password . ,my-jabber-password)
                             (:network-server . "talk.google.com") 
                             (:connection-type . ssl))))
#+END_SRC

Now, =jabber.el= has a bunch of honestly very odd defaults.  Firstly,
it tries to store avatars somewhere in my home folder.  Yep, more
shit there is definitely what I need.

#+BEGIN_SRC emacs-lisp
(setq jabber-avatar-cache-directory "/tmp/jabber-avatars")
#+END_SRC

The default prompts are just awfully wordy.  We fix this.

#+BEGIN_SRC emacs-lisp
(setq jabber-chat-buffer-show-avatar nil
      jabber-chat-foreign-prompt-format "> "
      jabber-chat-local-prompt-format "> "
      jabber-chat-system-prompt-format "*** "
      jabber-chat-time-format "%H:%M"
      jabber-default-show ""
      jabber-groupchat-prompt-format "%n> "
      jabber-muc-private-foreign-prompt-format "%g/%n> ")
#+END_SRC

There are also some assorted variables over here.  One day I'll
document them better.

#+BEGIN_SRC emacs-lisp
(setq jabber-backlog-days 3.0
      jabber-roster-line-format "%c %-25n %u %-8s"
      jabber-roster-show-title nil
      jabber-show-resources nil
      jabber-show-offline-contacts nil)
#+END_SRC

Some faces I want to set to make chatting more pleasant.

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(jabber-chat-prompt-foreign ((t (:foreground "red"))))
 '(jabber-chat-prompt-local ((t (:foreground "blue"))))
 '(jabber-chat-prompt-system ((t (:foreground "dark green" :weight bold))))
 '(jabber-roster-user-away ((t (:foreground "orange"))))
 '(jabber-roster-user-chatty ((t (:foreground "green"))))
 '(jabber-roster-user-online ((t (:foreground "dark green")))))
#+END_SRC

Lastly, I sometimes IM my friends URLs, and it's nice to make them all
hyperlink-y.

#+BEGIN_SRC emacs-lisp
; Auto-urlize urls
(add-hook 'jabber-chat-mode-hook 'goto-address)
(jabber-connect-all)
#+END_SRC

* Shells
** Shell mode

My fish shell prompt isn't detected too well.  Let's fix that.

#+BEGIN_SRC emacs-lisp
(setq shell-prompt-pattern ".*$>")
#+END_SRC

** Eshell

Eshell doesn't actually require that much prodding.  The only thing I
do is change its directory.

#+BEGIN_SRC emacs-lisp
(setq eshell-directory-name "~/.emacs.d/eshell/")
#+END_SRC

** Multi-term

Multiterm requires a bit more setup.

#+BEGIN_SRC emacs-lisp
(require 'multi-term)
(setq multi-term-program "/usr/bin/fish")
#+END_SRC

For simplicity, I also add the =mterm= command to just call
=multi-term=.

#+BEGIN_SRC emacs-lisp
(defun mterm ()
  (interactive)
  (multi-term))
#+END_SRC

One annoyance is that the screen bounces in multi-term due to my
=scroll-margin=.  But there's a solution: file-local variables.  We
attach a handler to =term-mode-hook= that makes =scroll-margin= local
and then sets it to =0=.  Because =make-local-variable= returns the
variable (as a symbol), we can call =set= (that's right: not =setq=,
but =set=, since we already have the variable quoted for us) to set
it.

#+BEGIN_SRC emacs-lisp
(add-to-list 'term-mode-hook (lambda ()
  (set (make-local-variable 'scroll-margin) 0)))
#+END_SRC
