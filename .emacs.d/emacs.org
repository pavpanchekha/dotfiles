#+TITLE: Emacs Initialization Script

I use Org's [[http://orgmode.org/worg/org-contrib/babel/intro.html#sec-8_2][Babel system]] for this configuration file. My =.emacs.d/init.el= file contains only:

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (package-initialize)
  (require 'ob-tangle)
  (org-babel-load-file "~/.emacs.d/emacs.org")
#+END_SRC

Since I publish this file on the Internet, I keep my passwords elsewhere:

#+BEGIN_SRC emacs-lisp
  (org-babel-load-file "~/.emacs.d/passwords.org")
#+END_SRC

* Packages

I install packages mostly from MELPA.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t)
#+END_SRC

Here are the packages I use; this table is [[http://sachachua.com/blog/2015/01/getting-data-org-mode-tables/][used by org-mode]] to install the packages.

#+NAME: packages
| Package         | Use                                        |
| better-defaults | Hide menus and fix some basic annoyances   |
| monokai-theme   | A colorful theme which I really like       |
| evil            | Vim key-bindings                           |
| evil-leader     | Set =SPC= as a leader key                  |
| helm            | A generic menu-driven Emacs plugin         |
| projectile      | A light-weight project tool                |
| paradox         | Better package management tools            |
| magit           | A git mode                                 |
| auto-complete   | Completions and suggestions                |
| org             | An organization tool                       |
| haskell-mode    | Editing haskell                            |
| quack           | Some additional scheme utils               |
| geiser          | A Scheme REPL                              |
| markdown-mode   | Editing markdown                           |
| typopunct       | Inserting proper punctuation automatically |

#+BEGIN_SRC emacs-lisp :var packages=packages
  (dolist (package (mapcar #'intern (mapcar #'first (rest packages))))
    (unless (package-installed-p package)
      (package-install package))
    (require package))
#+END_SRC

I generally manage these packages through the =paradox= tool, which I configure to interface with Github:

#+BEGIN_SRC emacs-lisp
(setf paradox-github-token my-github-token)
(setf paradox-star-automatically t)
(setf paradox-execute-asynchronously t)
#+END_SRC

* Personal Information

My name and email address helps Emacs format various messages.

#+BEGIN_SRC emacs-lisp
  (setf user-full-name "Pavel Panchekha")
  (setf user-mail-address "me@pavpanchekha.com")
#+END_SRC

I keep my custom-set variables separate from my true configuration file.

#+BEGIN_SRC emacs-lisp
  (setf custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+END_SRC

I store some collected data in Dropbox. To avoid one computer overwriting another's data, I include the hostname in the file name. This code extracts the hostname itself.

#+BEGIN_SRC emacs-lisp
  (setf hostname
        (with-temp-buffer
          (call-process "hostname" nil t)
          (let ((hostname* (buffer-string)))
            (while (string-match "[\r\n\t ]+" hostname*)
              (setq hostname* (replace-match "" t t hostname*)))
            hostname*)))
#+END_SRC

I keep a journal.

#+BEGIN_SRC emacs-lisp
  (defun my-open-journal ()
    (interactive)
    (find-file-other-window "~/Dropbox/journal.org"))
#+END_SRC

* Evil: key commands à la Vim

[[http://gitorious.org/evil/pages/Home][Evil]] is the Vim key-stroke language for Emacs.

#+BEGIN_SRC emacs-lisp
  (global-evil-leader-mode)
  (evil-leader/set-leader "SPC")
  (evil-mode 1)
#+END_SRC

By default Evil uses [[http://www.dr-qubit.org/undo-tree/undo-tree-0.6.4.el][undo-tree]], which represents previous document states as a tree. I, however, prefer the more confusing but simpler cyclic undo that comes with vanilla Emacs.

#+BEGIN_SRC emacs-lisp
  (global-undo-tree-mode -1)
#+END_SRC

Visual line mode is what Emacs calls “word wrap”. I use it in all text modes, so I ask Evil to execute commands on visual lines; otherwise these commands are =g $= and similar. The commands =I= and =A= should act similarly, but they do not yet have associated =-visual-line= versions.

#+BEGIN_SRC emacs-lisp
(define-key evil-motion-state-map "j" #'evil-next-visual-line)
(define-key evil-motion-state-map "k" #'evil-previous-visual-line)
(define-key evil-motion-state-map "$" #'evil-end-of-visual-line)
(define-key evil-motion-state-map "^" #'evil-first-non-blank-of-visual-line)
(define-key evil-motion-state-map "0" #'evil-beginning-of-visual-line)
#+END_SRC

Evil binds =RET=, which is often used in other modes. This unbinds it:

#+BEGIN_SRC emacs-lisp
(define-key evil-motion-state-map (kbd "RET") nil)
(define-key evil-motion-state-map (kbd " ") nil)
#+END_SRC

I have a few shortcuts using the =SPC= leader. They’re mostly bindings to Helm tools, but I plan to grow more one day.

#+NAME: evil-leader-bindings
| Key | Function            |
| SPC | helm-M-x            |
| f   | helm-find-files     |
| s   | save-buffer |
| b   | helm-mini           |
| h   | help-for-help       |
| p   | helm-projectile     |
| g   | helm-google-suggest |
| j   | my-open-journal     |

#+BEGIN_SRC emacs-lisp :var bindings=evil-leader-bindings
  (apply #'evil-leader/set-key
         (apply #'append (mapcar (lambda (row) (list (car row) (intern (cadr row)))) (cdr bindings))))
#+END_SRC

* Graphical Interface Quirks

I now use the =better-defaults= package to turn off the scroll bar, tool bar, and menu bar.

Instead of the menu bar, I put the mode line at the top of the document (a trick I took from [[http://bzg.fr/emacs-strip-tease.html][Bastien Guerry]]):

#+BEGIN_SRC emacs-lisp
  (setq-default header-line-format mode-line-format)
  (setq-default mode-line-format nil)
#+END_SRC

I no longer need the Emacs startup screen, so I turn it off. I usually start from the daemon anyway, so I’ll only see the startup screen once.

#+BEGIN_SRC emacs-lisp
  (setf inhibit-startup-screen t
        inhibit-startup-message t
        inhibit-startup-echo-area-message t)
#+END_SRC

Instead, I would rather Emacs open up by visiting the =~= directory, in which I store current projects.

#+BEGIN_SRC emacs-lisp
  (setf initial-buffer-choice "~/")
#+END_SRC

I’m still mulling this choice over—I’d prefer my Home directory to be a bit cleaner, and I’d prefer opening it without showing hidden files (of which there are too many, and which I’d also prefer to clean out. For now, there’s no escaping it.

The mode-line is made more useful by showing the column number and progress through the file. The column number is especially handy for avoiding long lines and for debugging error messages.

#+BEGIN_SRC emacs-lisp
  (setf column-number-mode t)
  (setf size-indication-mode t)
#+END_SRC

I hate my computer beeping when I err. I ask Emacs to express its discontent visually.

#+BEGIN_SRC emacs-lisp
  (setf visible-bell t)
#+END_SRC

I rarely use the mouse, so tooltips are an annoyance.  This code causes them to appear in the echo area instead.

#+BEGIN_SRC emacs-lisp
  (tooltip-mode -1)
  (setf tooltip-use-echo-area t)
#+END_SRC

For scrolling, I ask Emacs to scroll at most five lines at a time and to keep 5 lines between the cursor and the top/bottom of the page. This helps me keep my place in the document.

#+BEGIN_SRC emacs-lisp
(setf scroll-conservatively 5)
(setf scroll-margin 5)
#+END_SRC

I use a [[https://github.com/cathywu/TimeTracker][time tracker]] that records window titles.  This is more handy if I display the currently file path in the window title.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '((:eval (if (buffer-file-name)
                     (concat "Emacs: " (abbreviate-file-name (buffer-file-name)))
                   "Emacs: %b"))))
#+END_SRC

Hide hidden files and directories by default in =dired=.

#+BEGIN_SRC emacs-lisp
#+END_SRC

Turn on Flycheck everywhere

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC

* Auto-completion

The [[http://cx4a.org/software/auto-complete/][Auto Complete Mode]] provides in-line auto-completion. I actually see a lot of competition right now between Auto Complete Mode and Company Mode. Here’s hoping one wins out; I understand Company to be the older mode, but also still under active development.

#+BEGIN_SRC emacs-lisp
  (global-auto-complete-mode)
#+END_SRC

I hook up completions to Geiser, the Scheme evaluation mode. This gives good completion in Racket buffers.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "auto-complete"
    '(add-to-list 'ac-modes '(geiser-repl-mode geiser-mode) t))
#+END_SRC

Auto Complete Mode automatically enables itself in all buffers, so I don’t need much configuration. I ask it to use fuzzy matching, which accounts for typos.

#+BEGIN_SRC emacs-lisp
  (setf ac-use-fuzzy t)
#+END_SRC

* Org-mode

Org-mode indents description lists so as to keep a consistent left edge. I don't like this behavior.

#+BEGIN_SRC emacs-lisp
  (setf org-description-max-indent 0)
#+END_SRC

I prefer to hide the inline markup used by Org-mode.

#+BEGIN_SRC emacs-lisp
  (setf org-hide-emphasis-markers t)
  (setf org-hide-leading-stars t)
#+END_SRC

Org-mode needs more information to use alternate LaTeX document classes.  I put this information into a separate file so I can load it separately in Makefiles.

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/export.el")
#+END_SRC

I use org-journal for journaling.

#+BEGIN_SRC emacs-lisp
  (setf org-journal-dir "~/Dropbox/")
  (setf org-journal-file-format "journal.txt")
  (setf org-journal-date-prefix "#+TITLE: ")
  (setf org-journal-time-prefix "* ")
#+END_SRC

* Magit Git integration

[[http://magit.github.io/magit/][Magit]] is an incredible Emacs interface to the [[https://git-scm.com][Git version-control system]].
I have a Magit binding in my leader map:

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key "m" 'magit-status)
#+END_SRC

* Editing text
  
I’m writing text documents pretty often now—the life of a scientist involves a lot of papers, notes, meetings, websites. Normally these files use org-mode. I’d love to use Markdown for everything—Org-mode’s syntax is actually pretty ugly—but Markdown has problems of its own. That’s a rant for another day, but suffice it to say that I’m using org-mode for now.

I give Org-mode files a =txt= extension because this allows editing them on other devices. 

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
#+END_SRC

My BibTeX files contain paper commentaries, marked up in Org mode. BibTeX has this weird feature where everything BibTeX can’t parse it treats as a comment. So, it’s really easy to embed paper comments into the bibliography files.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.bib$" . org-mode))
#+END_SRC

=visual-line-mode= implements proper line wrapping, which I prefer. For Org mode I also turn on proportional fonts. But traditionally Markdown files are hard-wrapped, and use ASCII fixed-text conventions more. LaTeX files get the same treatment.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'visual-line-mode)
  (add-hook 'org-mode-hook 'variable-pitch-mode)

  (add-hook 'markdown-mode-hook 'auto-fill-mode)

  (add-hook 'latex-mode-hook 'auto-fill-mode)
  (add-hook 'latex-mode-hook 'variable-pitch-mode)
#+END_SRC

I’ve gone back and forth on single- and double-spaced sentences, but for now I’m in the single-spacing camp.

#+BEGIN_SRC emacs-lisp
  (setf sentence-end-double-space nil)
#+END_SRC

In text documents I prefer nice, Unicode punctuation. The =typopunct= package automatically inserts that, including em- and en-dashes, matching quotes, proper apostrophes, and so on.

#+BEGIN_SRC emacs-lisp
  (typopunct-change-language 'english t)
  (add-hook 'org-mode-hook 'typopunct-mode)
  (add-hook 'markdown-mode-hook 'typopunct-mode)
#+END_SRC

In the text modes I use, I turn on spell checking.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'flyspell-mode)
  (add-hook 'markdown-mode-hook 'flyspell-mode)
  (add-hook 'latex-mode-hook 'flyspell-mode)
#+END_SRC

To insert other Unicode characters, I use the TeX input mode that ships with Emacs:

#+BEGIN_SRC emacs-lisp
  (defun TeX-input-method () (set-input-method 'TeX))
  (add-hook 'org-mode-hook 'TeX-input-method)
  (add-hook 'markdown-mode-hook 'TeX-input-method)
  (add-hook 'latex-mode-hook 'TeX-input-method)
#+END_SRC

* Editing directories

Dired is great for exploring a file system and so on.

#+BEGIN_SRC emacs-lisp
  (require 'dired-x)

  (setf dired-omit-files "^\\.?#\\|^\\.")

  (defun dired-hide-details-home ()
    "Hide details and hidden files,
     if the current buffer is the home directory."
    (when (equal (expand-file-name default-directory) (expand-file-name "~/"))
      (dired-hide-details-mode)
      (dired-omit-mode)))

  (add-hook 'dired-mode-hook 'dired-hide-details-home)
#+END_SRC

* Spell checking

Fly-spell mode uses ISpell. I want to use the =ispell= program, to use American English, and to locate my personal dictionary within my =.emacs.d= directory.

#+BEGIN_SRC emacs-lisp
(setf ispell-program-name "/usr/bin/ispell")
(setf ispell-dictionary "american")
(setf ispell-personal-dictionary "~/.emacs.d/dict")
#+END_SRC

A key binding I really miss from Vim is the spell checking keys =zg= and =z==.  Emacs has a great spell-check built-in: Ispell. All we need to do is add a few key-bindings.  But first we need a function to bind to, and for =zg= (save current word to dictionary) one does not exist.  So off we go to implement =ispell-save-word.=

#+BEGIN_SRC emacs-lisp
(defun ispell-save-word () (interactive)
#+END_SRC

First, we need to *get* the current word.  We don't need to explicitly use =ispell-following-word=, since =ispell-get-word= does this for us. =ispell-get-word= returns a list of =word=, =start=, =end= (though its documentation certainly doesn't hint at such), so we call =car= to extract the word itself.

#+BEGIN_SRC emacs-lisp
  (let ((word (car (ispell-get-word nil))))
#+END_SRC

Now we can call =ispell-send-string=.  Its documentation is pretty weak (and that's if I want to be nice), but from reading the code of =ispell-command-loop= (search for =?i=), it seems like we want to send =*word\n=, where =word= is the word in question.

#+BEGIN_SRC emacs-lisp
  (ispell-send-string (concat "*" word "\n"))
#+END_SRC

Finally, since we modified the dictionary, we want to save it.  To be nice, we're going to first mark the dictionary as modified.  We only want to force a save, though, if the dictionary was clean before-hand, so we save the old value.

#+BEGIN_SRC emacs-lisp
  (let ((old-ispell-pdict-modified-p ispell-pdict-modified-p))
    (setq ispell-pdict-modified-p '(t))
#+END_SRC

And finally, we want force a save if necessary.  The "if necessary" part is actually annoyingly complicated...

#+BEGIN_SRC emacs-lisp
    (when (or (and old-ispell-pdict-modified-p
                   (listp old-ispell-pdict-modified-p)
                   (car ispell-pdict-modified-p))
              (and ispell-pdict-modified-p
                   (not (listp ispell-pdict-modified-p)))))
#+END_SRC

But once that's out of the way, we can just call =ispell-pdict-save= with =no-query=.

#+BEGIN_SRC emacs-lisp
      (ispell-pdict-save t))))
#+END_SRC

Finally, we add key-bindings using Evil's =evil-normal-state-map=.

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map "z=" 'ispell-word)
(define-key evil-normal-state-map "zg" 'ispell-save-word)
#+END_SRC

* Projectile

[[https://github.com/bbatsov/projectile][Projectile]] is a project management suite for Emacs. I enable it everywhere. It only does anything when I’m in a version-controlled directory, so there’s little harm in this.

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

* The =run= Command

I have command called =run=, which compiles and runs some program or file in a temporary directory.  I use it for compiling LaTeX or testing C code.

#+BEGIN_SRC emacs-lisp
  (defun run-command (file)
    (interactive (list (buffer-file-name)))
    (save-window-excursion
     (shell-command (concat "run " file " &"))))

  (defun compile-command (file)
    (interactive (list (buffer-file-name)))
    (save-window-excursion
     (shell-command (concat "run -c " file " &"))))
#+END_SRC

Then we attach them to =[f5]= and =[C-f5]=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") 'run-command)
  (global-set-key (kbd "C-<f5>") 'compile-command)
#+END_SRC

* Doc View
  
I sometimes use doc-view for long PDFs (though rarely now).

For long PDFs, continuous scrolling is best.

#+BEGIN_SRC emacs-lisp
  (setf doc-view-continuous t)
#+END_SRC

144 is a decent resolution, since it makes a page of text about as wide as half my screen, and I generally use Emacs with two vertical panes.

#+BEGIN_SRC emacs-lisp
  (setf doc-view-resolution 144)
#+END_SRC

Doc-view works much better with Vim-style h/j/k/l movement keys.

#+BEGIN_SRC emacs-lisp
  (require 'doc-view)
  (define-key doc-view-mode-map (kbd "j") 'doc-view-next-line-or-next-page)
  (define-key doc-view-mode-map (kbd "k") 'doc-view-previous-line-or-previous-page)
  (define-key doc-view-mode-map (kbd "h") 'image-backward-hscroll)
  (define-key doc-view-mode-map (kbd "l") 'image-forward-hscroll)
#+END_SRC

* Haskell programming tools

[[https://github.com/haskell/haskell-mode][Haskell Mode]] provides syntax highlighting and similar utilities for programming in Haskell. Multiple methods of indenting Haskell code come with Haskell Mode. They don't differ much, but I prefer =haskell-indentation=. I used to use =haskell-indent= but it annoyed me somehow.

#+BEGIN_SRC emacs-lisp
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
#+END_SRC

* Scheme programming tools

Several modes come together to make programming in Scheme enjoyable. I usually use the Racket dialect of Scheme, but I've used MIT-Scheme heavily in the past. Sadly, no package seems to support both. For now I use [[http://www.neilvandyke.org/quack/][Quack]] and [[http://www.nongnu.org/geiser/][Geiser]], which together make Racket a breeze.

Since I never use Guile, I configure Geiser to always start up in Racket mode.

#+BEGIN_SRC emacs-lisp
  (setf geiser-active-implementations '(racket))
#+END_SRC

It is customary in Racket to use a proper Unicode λ instead of the symbol =lambda=. I hack the abbreviation tools in Emacs to make this happen: I set =lambda= to be an abbreviation for =λ=.

#+BEGIN_SRC emacs-lisp
   (require 'abbrev)
   (add-hook 'scheme-mode-hook
     (lambda ()
       (abbrev-mode 1)
       (define-abbrev scheme-mode-abbrev-table "lambda" "λ")))
#+END_SRC

Perfectly matching parentheses is annoying; =electric-pair-mode= automatically inserts closing parentheses when I type the open parenthesis. This works great =show-paren-mode=, which automatically highlights the matching parenthesis (=show-paren-mode= is provided by =better-defaults=).

#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook 'electric-pair-mode)
#+END_SRC

Geiser provides auto-completion with =M-TAB=. I instead set up auto-complete using the auto-complete package.

#+BEGIN_SRC emacs-lisp
  (add-hook 'geiser-mode-hook 'ac-geiser-setup)
  (add-hook 'geiser-repl-mode-hook 'ac-geiser-setup)
#+END_SRC

Geiser stores history information; I'd prefer it not clutter my home directory.

#+BEGIN_SRC emacs-lisp
  (setf geiser-repl-history-filename "~/.emacs.d/geiser-history")
#+END_SRC

* Emacs Lisp programming tools

When I write emacs-lisp I am often in the debugger. To turn it on, I use this function:

#+BEGIN_SRC emacs-lisp
  (defun debug-mode () "Turn on various Emacs debugging features" (interactive)
    (setf debug-on-error t message-log-max 10000))
#+END_SRC

I'm also often shaving my Emacs configuration (this file). It's helpful to jump to it and reload it quickly.,

#+BEGIN_SRC emacs-lisp
(defun reconfigure () (interactive)
  (load-file "~/.emacs.d/init.el"))

(defun edconfigure () (interactive)
  (find-file "~/.emacs.d/emacs.org"))
#+END_SRC

* Coq programming tools

  Proof General is, of course, central to using Coq.

  #+BEGIN_SRC emacs-lisp
    (require 'proof)
  #+END_SRC

* Inter-Key Timings

One interesting characteristic of a person's typing is their inter-key timings -- the time between typing two letters in succession.  For example, it usually takes more time to type "cr" than ";l", since one involves moving the left index finger a large distance and the other uses the really natural rolling chord on the right hand.  By recording all key character pairs, we can actually track timings for this.  And since I do a lot of my work in Emacs, it is easiest to do this as an Emacs extension.

I've written such a thing: [[http://git.pavpanchekha.com/?p=keylogger.el.git;a=summary][keylogger.el]].  It has an Emacs Lisp extension and an analyzer written in Javascript.  I turn it on when Emacs starts:

#+BEGIN_SRC emacs-lisp
  (load "~/Dropbox/Work/keylogger.el/keylogger.el")
  (setf keylogger-filename (concat "~/Dropbox/Data/keys." hostname ".el"))
  (keylogger-load)
  (keylogger-start)
  (keylogger-autosave)
#+END_SRC

Note that each startup, I load the file, load my previously-saved data, tell it to record new key presses, and to autosave them every fifteen minutes.

* Printing Buffers to PDF

I once needed to print an Emacs buffer to PDF.  The standard printing commands rely on =lpr= and assume an actual printer. Instead I use the Emacs =printing= package to export buffers to Postscript, and then call =ps2pdf= to produce a PDF from the Postscript.

#+BEGIN_SRC emacs-lisp
(require 'printing)
#+END_SRC

We want to use the function =pr-ps-buffer-print= from the =printing= package.  We give it a temporary file to print to, and later we'll run =ps2pdf= on that file.

#+BEGIN_SRC emacs-lisp
  (defun print-to-pdf () (interactive)
    (let* ((outfile (make-temp-file pr-ps-temp-file))
           (pdffile (concat outfile ".pdf")))
      (pr-ps-buffer-print 1 outfile)
      (shell-command (concat "ps2pdf "
                             (shell-quote-argument outfile)
                             " "
                             (shell-quote-argument pdffile)))
      (find-file pdffile)))
#+END_SRC

The default print settings are silly for printing to PDF. I prefer syntax highlighting but no headers.

#+BEGIN_SRC emacs-lisp
  (setf pr-faces-p t)
  (setf ps-print-header nil)
  (setf ps-print-header-frame)
#+END_SRC
* Helm
  
Helm is an incredible search interface. It’s hard to describe, but it somehow improves on many of Emacs’s built-in utilities. I turn on Helm in a couple of places (but sadly not too many of them).

#+BEGIN_SRC emacs-lisp
  (helm-mode 1)
#+END_SRC

I use Helm’s version of find-file, search, apropos

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-s") 'helm-occur)
  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-h a") 'helm-apropos)
  (global-set-key (kbd "C-c h g") 'helm-google-suggest)
  (global-set-key (kbd "C-c h p") 'helm-projectile)
#+END_SRC

I don’t like the default use of =TAB= and =C-z=, so I switch them. Code from [[http://tuhdo.github.io/helm-intro.html][this Helm intro]].

#+BEGIN_SRC emacs-lisp
(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
(define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
(define-key helm-map (kbd "C-z")  'helm-select-action)
#+END_SRC

* Quick scratchpads

#+BEGIN_SRC emacs-lisp
    (defun scratchpad ()
      (interactive)
      (let ((scratchpad-buffer (get-buffer "*scratchpad*")))
        (if scratchpad-buffer
            (progn
              (switch-to-buffer scratchpad-buffer)
              (set-window-dedicated-p (selected-window) t)
              (setf header-line-format nil)
              (modify-frame-parameters nil '((title . "scratchpad"))))
          (eshell 0)
          (rename-buffer "*scratchpad*"))))
#+END_SRC
