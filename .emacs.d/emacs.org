#+TITLE: Emacs Initialization Script

All of my Emacs initialization is contained within this one Literate
Babel file.  I use the Babel system in Org-mode to evaluate the code
within on Emacs startup, which lets me write nice descriptive text for
my code.  My =.emacs.d/init.el= file contains only:

: (require 'ob-tangle)
: (org-babel-load-file "~/.emacs.d/emacs.org")

More on this method can be found [[http://orgmode.org/worg/org-contrib/babel/intro.html#sec-8_2][in the Babel tutorial]].

* Packages

  My Emacs configuration relies on several packages being installed.
  Luckily, Emacs now has a package manager.
  
#+BEGIN_SRC emacs-lisp
  (defun package-safe-install (package)
    (if (not (package-installed-p package))
        (package-install package)))
#+END_SRC

  Some packages I couldn't live without; there are:

   + evil        :: A good text editor for Emacs
   + org         :: Organization and markup system.
   + multi-term  :: Emacs =term= is impossible.  This is not.
   + magit       :: =git= in Emacs

  There are also a few languages modes that are nice to have around:
  =erlang=, =go-mode=, =haskell-mode=, =markdown-mode=.

#+BEGIN_SRC emacs-lisp
  (defvar *packages-core*
    '(evil org multi-term magit))

  (defvar *packages-extra*
    '(erlang go-mode haskell-mode markdown-mode magithub htmlize))
#+END_SRC

  We use the Marmalade repository on top of the GNU-maintained one.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("marmalade" . "http://marmalade-repo.org/packages/"))
  (package-initialize)
  
  (mapcar #'package-safe-install
          (append *packages-core* *packages-extra*))
#+END_SRC

* Personal Information

Emacs might as well know my name and email address.  I trust it.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Pavel Panchekha")
(setq user-mail-address "me@pavpanchekha.com")
#+END_SRC

Also, I like to keep my custom-set variables from polluting my other
files, so I like to move the =custom-file=.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

Since I publish this file on the Internet, I keep my passwords elsewhere:

#+BEGIN_SRC emacs-lisp
(org-babel-load-file "~/.emacs.d/passwords.org")
#+END_SRC

Finally, a few files are stored once for each computer and then synchronized over Dropbox.  To keep things sane, each computer's file is named by its hostname.  This bit of code extracts the hostname itself.

#+BEGIN_SRC emacs-lisp
  (setf hostname
        (with-temp-buffer
          (call-process "hostname" nil t)
          (let ((hostname* (buffer-string)))
            (while (string-match "[\r\n\t ]+" hostname*)
              (setq hostname* (replace-match "" t t hostname*)))
            hostname*)))
#+END_SRC

* Key Bindings

We use the [[http://gitorious.org/evil/pages/Home][Evil package]] for Vim keybindings in Emacs.

#+BEGIN_SRC emacs-lisp
  (require 'evil)
  (evil-mode 1)
#+END_SRC

But I actually rather like the cyclic undo that Emacs has.  Since Evil mode turns on undo-tree by default, we need to turn it off.

#+BEGIN_SRC emacs-lisp
  (global-undo-tree-mode t)
#+END_SRC

** Key-map commands

Since I like Vim key-bindings everywhere, I'll be doing a lot of
adding to key-maps.  This gets tedious, especially when lots of keys
on the same key-map.  This macro makes adding a bunch of keys to the
same key-map very easy.

#+BEGIN_SRC emacs-lisp
  (require 'cl) ; For LOOP

  (defmacro define-keys (map &rest keys)
    "Adds several key bindings to a specific map.  Takes a map (as
    a bare symbol) and a several clauses of form (key func); key is
    a string to be passed to (kbd), and func is a function name."
    (declare (indent defun))

    `(progn
       ,@(cl-loop for key+func in keys
                  collect `(define-key ,map
                             (kbd ,(car key+func))
                             ',(cadr key+func)))))
#+END_SRC

** Visual Line Mode hacks

I like to use visual line mode for text files (more semantic
information!), so I have the following hack for Evil:

#+BEGIN_SRC emacs-lisp
(define-key evil-motion-state-map "j" #'evil-next-visual-line)
(define-key evil-motion-state-map "k" #'evil-previous-visual-line)
(define-key evil-motion-state-map "$" #'evil-end-of-visual-line)
(define-key evil-motion-state-map "^" #'evil-first-non-blank-of-visual-line)
(define-key evil-motion-state-map "0" #'evil-beginning-of-visual-line)
#+END_SRC

Note that these work fine in hard-wrapped text, too; they're
just not as necessary.  Also note that commands like =I= and =A=
should in theory also receive this treatment, but alas, they
don't have associated =-visual-line= versions.

** Miscellaneous

I prefer to work with indented text at all times, so =RET= should be
bound to =newline-and-indent=, and some terminals have problems with
the delete key or something, so I keep the following bindings around
as well.  The last line there make =C-k= kill the whole line.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
(global-set-key [delete] 'delete-char)
(setq kill-whole-line t)
#+END_SRC

** Doc-View

I generally use doc-vew for long PDFs, so I find it best to have
continuous scrolling.

#+BEGIN_SRC emacs-lisp
(setq doc-view-continuous t)
#+END_SRC

144 is a decent resolution, since it makes a page of text about as
wide as half my screen (and I generally use Emacs with two vertical
panes.

#+BEGIN_SRC emacs-lisp
(setq doc-view-resolution 144)
#+END_SRC

The PDF viewer is in sore need of Vim-style h/j/k/l movement keys

#+BEGIN_SRC emacs-lisp
(require 'doc-view)
(define-keys doc-view-mode-map
    ("j" doc-view-next-line-or-next-page)
    ("k" doc-view-previous-line-or-previous-page)
    ("h" image-backward-hscroll)
    ("l" image-forward-hscroll))
#+END_SRC

* Miscellany
** GUI Settings

Some things Emacs does by default just use up screen real estate and
programmer patience.  Note that =tool-bar-mode= requires a *nonzero*
parameter, not a truthy parameter, to display the toolbar.  This is
absolutely absurd, but what can one do?

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message t)
(set-scroll-bar-mode nil)
(tool-bar-mode 0)
#+END_SRC

I'm not yet pro enough to forsake =menu-bar-mode=, though one day I'll
get there.

Also, I like knowing where my files end; ergo I ask Emacs to show
empty lines.

#+BEGIN_SRC emacs-lisp
(if (not indicate-empty-lines)
  (toggle-indicate-empty-lines))
#+END_SRC

The modeline should really be pressed into useful service.  I make it
display the time, and for the position display, have it give the column
number and file size:

#+BEGIN_SRC emacs-lisp
(display-time-mode t)
(setq column-number-mode t)
(setq size-indication-mode t)
#+END_SRC

The =yes or no= prompts get annoying quickly.  Instead, we ask Emacs to
use single-character responses

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Whenever I do something that Emacs finds odd, it beeps.  Why?  Who
knows.  In any case, I turn it off, because when I'm lounging about
with music on the overhead speakers, I don't want a beep interfering.

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

Since I rarely use the mouse, tooltips are more an annoyance than
anything else.  This switches them to appear in the echo area.

#+BEGIN_SRC emacs-lisp
(tooltip-mode -1)
(setq tooltip-use-echo-area t)
#+END_SRC

I'm old enough for no training wheels.  Narrowing a buffer hides
certain text, which is nice for focusing and buffer-cloning magic.

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

I use a time tracker that keys off window titles.  Thus, I'd like the
currently-active file in the window title:

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '((:eval (if (buffer-file-name)
                     (concat "Emacs: " (abbreviate-file-name (buffer-file-name)))
                   "Emacs: %b"))))
#+END_SRC

** Visual Line Mode Hacks

I like using visual-line-mode, especially when editing text.  But this is problematic if the width of the window is very large, since in that case the line doesn't wrap until it is 100 or so characters long.  To fix this, I use a minor mode that I myself wrote, =center-text-mode=:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path
               "~/Dropbox/Work/center-text.el/")
  (require 'center-text)
#+END_SRC

** Basic File Behaviors

Emacs has some stupid defaults, such as making those =file~= files and
using tabs for indentation.  I also make Emacs add final newlines and
to prompt me for only single characters (why is that default?).

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq-default indent-tabs-mode nil)
(setq require-final-newline t)
#+END_SRC

Also, I often have multiple buffers open with the same name.  Emacs
usually deals with this by appending the buffer number to the buffer
name.  This is hard to keep track of.  Instead, the =uniquify= library
uses the parent directory name, which I usually know.

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'post-forward-angle-brackets)
#+END_SRC

** Searching and Scrolling

For searching, I enable highlighting as-I-search for both searches and
search/replaces.  Also, searches are made case-insensitive.

#+BEGIN_SRC emacs-lisp
(setq search-highlight t)
(setq query-replace-highlight t)
(setq case-fold-search t)
#+END_SRC emacs-lisp

For scrolling, I ask Emacs to scroll at most five lines at a time and
to keep 5 lines between the cursor and the top/bottom of the page.

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 5)
(setq scroll-margin 5)
#+END_SRC

* Utility Commands
** Debugging

Every once in a while, I develop in emacs-lisp, and make use of the
following:

#+BEGIN_SRC emacs-lisp
  (defun debug-mode ()
    "Turn on various Emacs debugging features"
    (interactive)

    (setf debug-on-error t message-log-max 10000))
#+END_SRC

** =run= Command

I have a =run= command that I rather like; it compiles and runs some
program or file in a temporary program.  I use it for, for example,
compiling LaTeX, or testing C code.

#+BEGIN_SRC emacs-lisp
  (defun run-command (file)
    (interactive (list (buffer-file-name)))
    (save-window-excursion
     (shell-command (concat "run " file " &"))))

  (defun compile-command (file)
    (interactive (list (buffer-file-name)))
    (save-window-excursion
     (shell-command (concat "run -c " file " &"))))
#+END_SRC

hThen we attach them to =[f5]= and =[C-f5]=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f5>") 'run-command)
(global-set-key (kbd "C-<f5>") 'compile-command)
#+END_SRC
** Configuration editing configuration

I actually edit my Emacs configuration a lot.  I call it "cultivating"
my Emacs configuration.  So here are some utility functions for that.

The first function just reloads the Emacs configuration.

#+BEGIN_SRC emacs-lisp
(defun reconfigure ()
  (interactive)
  (load-file "~/.emacs.d/init.el"))
#+END_SRC

The second function opens the configuration up for editing.

#+BEGIN_SRC emacs-lisp
(defun edconfigure ()
  (interactive)
  (find-file "~/.emacs.d/emacs.org"))
#+END_SRC

* Printing Buffers to PDF

Sometimes, I need to print an Emacs buffer to PDF.  The standard
printing commands are less than ideal for this, since they rely on
=lpr=, a program I have no interest in installing and configuring.
Instead, I can use the Emacs =printing= package, which can export
buffers to Postscript, and then call =ps2pdf= to produce a PDF from
the Postscript.

First, I =require= in the =printing= package and ask it to install
itself into the Emacs menu tree.

#+BEGIN_SRC emacs-lisp
(require 'printing)
#+END_SRC

Now we write a function to print the current buffer.

#+BEGIN_SRC emacs-lisp
(defun print-to-pdf ()
  (interactive)
#+END_SRC

We want to use the function =pr-ps-buffer-print= from the =printing=
package.  We give it a temporary file to print to, and later we'll
=ps2pdf= that file.

#+BEGIN_SRC emacs-lisp
  (let* ((outfile (make-temp-file pr-ps-temp-file))
         (pdffile (concat outfile ".pdf")))
    (pr-ps-buffer-print 1 outfile)
    (shell-command (concat "ps2pdf "
                           (shell-quote-argument outfile)
                           " "
                           (shell-quote-argument pdffile)))
    (find-file pdffile)))
#+END_SRC

The default print settings are silly, especially once you consider
that my use case is print-to-PDF.  So I would rather print with syntax
highlighting and no headers.

#+BEGIN_SRC emacs-lisp
(setq pr-faces-p t
      ps-print-header nil
      ps-print-header-frame)
#+END_SRC

* Ispell

Of course, if we're activating ISpell, we should set it up.  Firstly
we want to tell it to use =ispell=, to check spelling against American
English, and where my dictionary is.

#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "/usr/bin/ispell")
(setq ispell-dictionary "american")
(setq ispell-personal-dictionary "~/.emacs.d/dict")
#+END_SRC

** =ispell-save-word= and Vim Spell-checking

A key binding I really miss from Vim is the spell checking keys
=zg= and =z==.  Emacs has a great spell-check built-in: Ispell.
All we need to do is add a few key-bindings.  But first we need
a function to bind to, and for =zg=, one does not exist.  So off
we go to implement =ispell-save-word.=

#+BEGIN_SRC emacs-lisp
(defun ispell-save-word ()
  (interactive)
#+END_SRC

First, we need to *get* the current word.  We don't need to explicitly
use =ispell-following-word=, since =ispell-get-word= does this for us.
=ispell-get-word= returns a list of =word=, =start=, =end= (though its
documentation certainly doesn't hint at such), so we call =car= to
extract the word itself.

#+BEGIN_SRC emacs-lisp
  (let ((word (car (ispell-get-word nil))))
#+END_SRC

Now we can call =ispell-send-string=.  Its documentation is pretty
weak (and that's if I want to be nice), but from reading the code of
=ispell-command-loop= (search for =?i=), it seems like we want to send
=*word\n=, where =word= is the word in question.

#+BEGIN_SRC emacs-lisp
  (ispell-send-string (concat "*" word "\n"))
#+END_SRC

Finally, since we modified the dictionary, we want to save it.  To be
nice, we're going to first mark the dictionary as modified.  We only
want to force a save, though, if the dictionary was clean before-hand,
so we save the old value.

#+BEGIN_SRC emacs-lisp
  (let ((old-ispell-pdict-modified-p ispell-pdict-modified-p))
    (setq ispell-pdict-modified-p '(t))
#+END_SRC

And finally, we want force a save if necessary.  The "if necessary"
part is actually annoyingly complicated...

#+BEGIN_SRC emacs-lisp
    (when (or (and old-ispell-pdict-modified-p
                   (listp old-ispell-pdict-modified-p)
                   (car ispell-pdict-modified-p))
              (and ispell-pdict-modified-p
                   (not (listp ispell-pdict-modified-p)))))
#+END_SRC

But once that's out of the way, we can just call =ispell-pdict-save=
with =no-query=.

#+BEGIN_SRC emacs-lisp
      (ispell-pdict-save t))))
#+END_SRC

Finally, we add key-bindings using Evil's =evil-normal-state-map.

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map "z=" 'ispell-word)
(define-key evil-normal-state-map "zg" 'ispell-save-word)
#+END_SRC

* Mode-specific Behaviors

I like Org-mode a lot; it should be default for text files.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
#+END_SRC

Other modes I use are Markdown (it's the standard) and $\LaTeX$ (for class):

#+BEGIN_SRC emacs-lisp
(add-hook 'latex-mode-hook 'auto-fill-mode)
(add-hook 'markdown-mode-hook 'visual-line-mode)
(add-hook 'org-mode-hook   'visual-line-mode)

(add-hook 'latex-mode-hook 'flyspell-mode)
(add-hook 'markdown-mode-hook 'flyspell-mode)
(add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC

* Org Mode

First things first!  We should set up the file structure.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/notes/")
(setq org-default-notes-file (concat org-directory "pavel.txt"))
#+END_SRC

Let's throw in a very minor editing thing (hitting =M-RET= shouldn't
split a bullet point in two).

#+BEGIN_SRC emacs-lisp
(setq org-M-RET-may-split-line '((default)))
#+END_SRC

Finally, Org-mode has this odd love of indenting the entries in
description lists so that there is a consistent left edge.  I don't
like it, and luckily I can turn it off.

#+BEGIN_SRC emacs-lisp
(setq org-description-max-indent 0)
#+END_SRC

** Agenda View

I use the agenda view a lot, so I customize it a bit.  The agenda
should show two days (including, yes, the ones without events); it
shouldn't show me things I've done; and I won't worry about starting
on a weekend or weekday.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-ndays 1)
  (setq org-agenda-span 2)
  (setq org-deadline-warning-days 3)

  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-start-on-weekday nil)
#+END_SRC

Since all of my TODO entries are in one file, I don't need the agenda
view to tell me what file a TODO entry comes from.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-file-regexp "\\`[^.].*\\.\\(txt\\|org\\)\\'")
  (setq org-agenda-files '("~/notes/"))
  (setq org-agenda-prefix-format
        '((agenda . " %i %?-12t% s")
          (timeline . "  % s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
#+END_SRC

Finally, given my use of the TODO list, I would like fewer deadline
reminders and more scheduled reminders

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown nil)
#+END_SRC

** Todo Keywords

The keywords here represent a good chunk of possible work-flows.  TODO
to DONE is the standard one, but sometimes I go to WONT or spent time
cycling between TODO and WAIT.  SOMEDAY exists for the projects that
I'd like to do, but that are currently in limbo.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "SOMEDAY(s)" "|" "DONE(d)" "WAIT(w)" "WONT(n)")))
(setq org-use-fast-todo-selection t)
#+END_SRC

** Entities
Since I use things like \RR so often, I made them into entities, so that
Org can typeset them nicely.

#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t
        org-entities-user '(; Double-struck letters for various fields
                            ("CC" "\\CC" t "&#8450;" "C" "C" "ℂ")
                            ("FF" "\\FF" t "&#120125;" "F" "F" "𝔽")
                            ("HH" "\\HH" t "&#8461;" "H" "H" "ℍ")
                            ("NN" "\\NN" t "&#8469;" "N" "N" "ℕ")
                            ("PP" "\\PP" t "&#8473;" "P" "P" "ℙ")
                            ("QQ" "\\QQ" t "&#8474;" "Q" "Q" "ℚ")
                            ("RR" "\\RR" t "&#8477;" "R" "R" "ℝ")
                            ("ZZ" "\\ZZ" t "&#8484;" "Z" "Z" "ℤ")

                            ; Fraktur letters for ideals
                            ("ga" "\\ga" t "&#120094;" "a" "a" "𝔞")
                            ("gb" "\\gb" t "&#120095;" "b" "b" "𝔟")
                            ("gc" "\\gc" t "&#120096;" "c" "c" "𝔠")
                            ("gd" "\\gd" t "&#120097;" "d" "d" "𝔡")
                            ("gm" "\\gm" t "&#120106;" "m" "m" "𝔪")
                            ("gn" "\\gn" t "&#120107;" "n" "n" "𝔫")
                            ("go" "\\go" t "&#120108;" "o" "o" "𝔬")
                            ("gp" "\\gp" t "&#120109;" "p" "p" "𝔭")
                            ("gq" "\\gq" t "&#120110;" "q" "q" "𝔮")

                            ; Miscellaneous mathematical
                            ("setminus" "\\setminus" t "&#8726;" "\" "\" "∖")
                            ("mapsto"   "\\mapsto" t "&#8614;" "|->" "|->" "↦")
                            ))
#+END_SRC

I also would rather hide the stars and such that org-mode uses for
inline markup:

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

** Key bindings

Some key bindings are not bound by Org automatically, so I have to bind
them myself.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
#+END_SRC

** LaTeX Export

Org-mode requires you to define things to use other classes for LaTeX
files.  I put this in a separate file so I can avoid loading it when
I'm just exporting.

#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/export.el")
#+END_SRC

* Mu For Emacs

I'm now reading my mail in =mu4e=, from the =mu-git= Arch Linux package.
This package is a lot like =notmuch= in that it's search-based and
works well with =offlineimap=, but has a much nicer interface and tries
very hard to stay compatible with the upstream IMAP folder.

#+BEGIN_SRC emacs-lisp :tangle nil
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
(require 'mu4e)
#+END_SRC

I need to tell Mu which folders store what on my system.  Note that I
only sync "important" messages with GMail to my system, so the
archive folder is the "important" folder.

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf mu4e-maildir "~/mail"
        mu4e-sent-folder "/sent"
        mu4e-drafts-folder "/drafts"
        mu4e-trash-folder "/trash"
        mu4e-refile-folder "/important")
  (setf mu4e-attachment-dir  "/tmp")
#+END_SRC

Mail is synced with =offlineimap=, so I tell Mu to run that to get new
mail.  OfflineIMAP will automatically run the Mu indexer.

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf mu4e-get-mail-command "mu index -m ~/mail --my-address me@pavpanchekha.com")
#+END_SRC

Finally, since I'm using GMail, GMail will automatically deal with
filing sent messages, so I can tell Mu to just delete sent messages.

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf mu4e-sent-messages-behavior 'delete)
#+END_SRC

In all of the =mu4e= modes, I want the Evil extensions off, since they
do naught but get in the way.  But somehow, this doesn't work for
=mu4e-view-mode=, so we use a special dispension for that.

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf evil-emacs-state-modes (list* 'mu4e-headers-mode 'mu4e-main-mode
                                      'mu4e-main-mode 'mu4e-view-mode
                                      evil-emacs-state-modes))
  (add-hook 'mu4e-view-mode-hook 'evil-emacs-state)
#+END_SRC

There're a few graphical things to change about Mu4e:

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf mu4e-use-fancy-chars t)
  (setf mu4e-view-show-images t)
  (setf mu4e-headers-skip-duplicates t)
  (setf mu4e-headers-include-related t)
#+END_SRC

** Sending mail

My mail gets sent through the GMail IMAP server. I used to use msmtp for sending mail, but I’ve now switched to using smtpmail.el, since it’s nice to have an Emacs-native solution.

#+BEGIN_SRC emacs-lisp
(setq send-mail-function 'smtpmail-send-it)
(setq message-send-mail-function 'smtpmail-send-it)
#+END_SRC

We now set up SMTPMail to use GMail.

#+BEGIN_SRC emacs-lisp
(setq smtpmail-smtp-server "smtp.gmail.com")
(setq smtpmail-smtp-service 587)
#+END_SRC

We then set up TLS for GMail’s connection:

#+BEGIN_SRC emacs-lisp
  (setq starttls-use-gnutls t)

  (setq smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        smtpmail-smtp-user "me@pavpanchekha.com"
        smtpmail-local-domain "pavpanchekha.com"
        smtpmail-sendto-domain "pavpanchekha.com"
        smtpmail-debug-info t)

  (require 'smtpmail)
#+END_SRC

** Composing messages

When composing replies, there are a few things I change from their defaults.  Firstly, I prefer quotes not to have citations, since I rarely participate in massive, many-person email threads.

#+BEGIN_SRC emacs-lisp
(setf message-citation-line-format "")
#+END_SRC

I also have a standard signature.

#+BEGIN_SRC emacs-lisp
(setf message-signature " - Pavel Panchekha")
#+END_SRC

** Bookmarks

I have a few bookmarks that set up my email flow.

#+BEGIN_SRC emacs-lisp :tangle nil
  (setf mu4e-maildir-shortcuts
    '(("/inbox" . ?i)
      ("flag:unread AND maildir:/important"  . ?u)))
#+END_SRC

* Shells

The Emacs shell mode is great, but barfs on ANSI escape sequence.  There's a fix:

#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+END_SRC

** Eshell

Eshell doesn't actually require that much prodding.  The only thing I
do is change its directory.

#+BEGIN_SRC emacs-lisp
  (setq eshell-directory-name "~/.emacs.d/eshell/")
#+END_SRC

Eshell has an awesome "smart mode" where it emulates Plan 9 by
allowing you to edit command lines instead of re-executing them.  Here
I tell Eshell to not review commands that successfully exit, since
those are normally easy to re-execute anyways.

#+BEGIN_SRC emacs-lisp
  (require 'eshell)
  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)
#+END_SRC

Eshell lets you redirect to a buffer with the syntax

: cmd >> #<buffer *scratch*>

or to Elisp variables with

: cmd > #'adsf

Since I don't expect to use the second feature at all, I'd prefer its
syntax be used for buffer redirections instead.

#+BEGIN_SRC emacs-lisp
  (setq eshell-buffer-shorthand t)
#+END_SRC

** Multi-term

Multiterm requires a bit more setup.

#+BEGIN_SRC emacs-lisp
(require 'multi-term)
(setq multi-term-program "/bin/bash")
#+END_SRC

For simplicity, I also add the =mterm= command to just call
=multi-term=.

#+BEGIN_SRC emacs-lisp
(defun mterm ()
  (interactive)
  (multi-term))
#+END_SRC

One annoyance is that the screen bounces in multi-term due to my
=scroll-margin=.  But there's a solution: file-local variables.  We
attach a handler to =term-mode-hook= that makes =scroll-margin= local
and then sets it to =0=.  Because =make-local-variable= returns the
variable (as a symbol), we can call =set= (that's right: not =setq=,
but =set=, since we already have the variable quoted for us) to set
it.

#+BEGIN_SRC emacs-lisp
(add-to-list 'term-mode-hook (lambda ()
  (set (make-local-variable 'scroll-margin) 0)))
#+END_SRC

* Dropbox

[[http://github.com/pavpanchekha/dropbox.el/][dropbox.el]] is a Dropbox client I wrote -- it accesses files from
Dropbox through the [[http://developers.dropbox.com][Dropbox API]].  It needs a bit of setup, mostly to
set the API secret and key.  The actual values are in the [[file:passwords.org][passwords
file]], but I unpack them here to remind myself that the entry in the
passwords file exists.

#+BEGIN_SRC emacs-lisp
(load "~/Dropbox/Work/dropbox.el/dropbox.el")
(setf dropbox-consumer-key    (car  my-dropbox-key))
(setf dropbox-consumer-secret (cadr my-dropbox-key))
#+END_SRC

Since I don't have many concurrent clients and rarely use shared
folders, a longer cache time makes a lot of sense.

#+BEGIN_SRC emacs-lisp
(setf dropbox-cache-timeout 300)
#+END_SRC

* Inter-Key Timings

One interesting characteristic of a person's typing is their inter-key
timings -- the time between typing two letters in succession.  For
example, it usually takes more time to type "cr" than ";l", since one
involves moving the left index finger a large distance and the other
uses the really natural rolling chord on the right hand.  By recording
all key character pairs, we can actually track timings for this.  And
since I do a lot of my work in Emacs, it is easiest to do this as an
Emacs extension.  I've written such a thing: [[http://git.pavpanchekha.com/?p=keylogger.el.git;a=summary][keylogger.el]].  It has an
Emacs Lisp extension and an analyzer written in Javascript.  Anyway,
I'd like to turn it on when Emacs starts:

#+BEGIN_SRC emacs-lisp
(load "~/Dropbox/Work/keylogger.el/keylogger.el")
(setf keylogger-filename (concat "~/Dropbox/Data/keys." hostname ".el"))
(keylogger-load)
(keylogger-start)
(keylogger-autosave)
#+END_SRC

Note that each startup, I load the file, load my previously-saved
data, tell it to record new key presses, and to autosave them every
fifteen minutes.
